# a1043 Is It a Binary Search Tree (25 分)（二叉搜索树）

A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

If we swap the left and right subtrees of every node, then the resulting tree is called the **Mirror Image** of a BST.

Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤1000). Then *N* integer keys are given in the next line. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first print in a line `YES` if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or `NO` if not. Then if the answer is `YES`, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
8 6 5 7 10 8 11
```

### Sample Output 1:

```out
YES
5 7 6 8 11 10 8
```

### Sample Input 2:

```in
7
8 10 11 8 6 7 5
```

### Sample Output 2:

```out
YES
11 8 10 7 5 6 8
```

### Sample Input 3:

```in
7
8 6 8 5 10 9 11
```

### Sample Output 3:

```out
NO
```

~~~C++
#include<iostream>
#include<vector>
#include <algorithm>
using namespace std;
vector<int> pre,post;bool isMirror=false;
void PostOrder(int start,int eend){
    if(start>eend) return ;
    int root=start,leftEnd=eend,RightStart=start+1;
    if(!isMirror){
        while(leftEnd>=root+1&&pre[root]<=pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]>pre[RightStart]) RightStart++;
    }
    else{//修改耗时
        while(leftEnd>=root+1&&pre[root]>pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]<=pre[RightStart]) RightStart++;
    }
    if(RightStart-leftEnd!=1) return;//耗时部分临界点的处理
    PostOrder(root+1,leftEnd);
    PostOrder(RightStart,eend);
    post.push_back(pre[root]);
}
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    for(int i=0;i<n;i++)
        scanf("%d",&pre[i]);
    PostOrder(0,n-1);
    if((int)post.size()<n){
        isMirror=true;
        post.clear();//忘了清理；
        PostOrder(0,n-1);
    }
    if((int)post.size()<n) printf("NO\n");
    else {
        printf("YES\n");
        for(int i=0;i<n;i++)
            printf("%d%c",post[i],i==n-1?'\n':' ');
    }
    return 0;
}
//要给定搜索序列的开始和结束为位置，给出正常的终止条件给出异常的判断
//柳神的思路：给出了一个重要的二叉树思想，递归的处理序列，在什么位置处理就是什么位置的遍历十分简洁高效

~~~



# **1090** **Highest Price in Supply Chain** **(25** **分**)（树的遍历）

A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.

Starting from one root supplier, everyone on the chain buys products from one's supplier in a price *P* and sell or distribute them in a price that is *r*% higher than *P*. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.

Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers.

### Input Specification:

Each input file contains one test case. For each case, The first line contains three positive numbers: *N* (≤105), the total number of the members in the supply chain (and hence they are numbered from 0 to *N*−1); *P*, the price given by the root supplier; and *r*, the percentage rate of price increment for each distributor or retailer. Then the next line contains *N* numbers, each number *S**i* is the index of the supplier for the *i*-th member. *S**r**o**o**t* for the root supplier is defined to be −1. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed 1010.

### Sample Input:

```in
9 1.80 1.00
1 5 4 4 -1 4 5 3 6
```

### Sample Output:

```out
1.85 2
```

~~~c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
int maxDepth=0,num=1;
vector<int> tree[100010];
void dfs(int index,int d){
    if(tree[index].empty()){
        if(d>maxDepth){
            maxDepth=d;
            num=1;
        }else if(d==maxDepth){
            num++;
        }
    }
    for(int i=0;i<(int)tree[index].size();i++){
        dfs(tree[index][i],d+1);
    }
    return;
}
double p,r,maxPrice;
int main(){
    int n;
    scanf("%d%lf%lf",&n,&p,&r);
    r/=100;int root=0,tmp;
    for(int i=0;i<n;i++){
        scanf("%d",&tmp);//不熟悉下标和值的关系
        if(tmp==-1) root=i;
        else tree[tmp].push_back(i);
    }
    dfs(root,0);
    maxPrice=p*pow(1+r,maxDepth);
    printf("%.2f %d",maxPrice,num);

    return 0;
}
~~~



# 1119 Pre- and Post-order Traversals (30 分)（二叉树的遍历）



Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.

Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first printf in a line `Yes` if the tree is unique, or `No` if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
```

### Sample Output 1:

```out
Yes
2 1 6 4 7 3 5
```

### Sample Input 2:

```in
4
1 2 3 4
2 4 3 1
```

### Sample Output 2:

```out
No
2 1 3 4
```



```C++
#include<iostream>
#include<vector>
using namespace std;
vector<int> pre,post,in;
bool isUnique=true;int inPos=0;
void inOrder(int root,int start,int eend){
    if(start>eend) return;
    int leftEnd=eend;
    while(pre[root+1]!=post[leftEnd]&&leftEnd!=-1) leftEnd--;
    int leftEndSize=leftEnd-start+1;
    if((start-eend+1)%2==0) isUnique=false;
    inOrder(root+1,start,leftEnd);
    in[inPos++]=pre[root];
    if(leftEnd!=-1) inOrder(root+1+leftEndSize,leftEnd+1,eend-1);
    else inOrder(root+1+leftEndSize,start+1,eend-1);//这里写错了逻辑不清楚，
}
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    post.resize(n);
    in.resize(n);
    for(int i=0;i<n;i++) scanf("%d",&pre[i]);
    for(int i=0;i<n;i++) scanf("%d",&post[i]);
    inOrder(0,0,n-1);
    if(isUnique) printf("Yes\n");
    else printf("No\n");
    for(int i=0;i<n;i++)
        printf("%d%c",in[i],i==n-1?'\n':' ');
    return 0;
}
/*******************************************/
/*
逻辑不清楚，首先start和end谁是谁的没搞清楚
应该一个序列提供跟节点一个序列利用自己去锁定下一个根节点；同时更新一下自己的查找范围。
此外本次不同于普通的中序遍历，会出现特殊结果leftEnd=-1；的情况，没有充分考虑=-1的情况下
对后续的程序的影响（例如右子树的后序的锁定范围会出现变化）

逻辑想的慢：
正常：第一次做前后序转中序；难免会对下一次取值生疏
但是下次可以考量一下什么函数要做什么，这个变量的意义
如root start eend的意义搞清楚后就不会有模糊的地方了。

模板改进题：
如果出现了新的值要考虑对原有模板的代码的影响

学习方式：
搞清楚模板函数各个参量的意义，改变他会有造成什么影响

调试窗口的调用：
调试-》调试窗口-》监视
调试-》调试窗口-》调用栈
*/
/********************************************/


```

# 1114 Family Property (25 分)（并查集）



This time, you are supposed to help us collect the data for family-owned property. Given each person's family members, and the estate（房产）info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤1000). Then *N* lines follow, each gives the infomation of a person who owns estate in the format:

```
ID` `Father` `Mother` *k* *C**h**i**l**d*1⋯*C**h**i**l**d**k* *M**e**s**t**a**t**e* `Area
```

where `ID` is a unique 4-digit identification number for each person; `Father` and `Mother` are the `ID`'s of this person's parents (if a parent has passed away, `-1` will be given instead); *k* (0≤*k*≤5) is the number of children of this person; *C**h**i**l**d**i*'s are the `ID`'s of his/her children; *M**e**s**t**a**t**e* is the total number of sets of the real estate under his/her name; and `Area` is the total area of his/her estate.

### Output Specification:

For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format:

`ID` `M` *A**V**G**s**e**t**s* *A**V**G**a**r**e**a*

where `ID` is the smallest ID in the family; `M` is the total number of family members; *A**V**G**s**e**t**s* is the average number of sets of their real estate; and *A**V**G**a**r**e**a* is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID's if there is a tie.

### Sample Input:

```in
10
6666 5551 5552 1 7777 1 100
1234 5678 9012 1 0002 2 300
8888 -1 -1 0 1 1000
2468 0001 0004 1 2222 1 500
7777 6666 -1 0 2 300
3721 -1 -1 1 2333 2 150
9012 -1 -1 3 1236 1235 1234 1 100
1235 5678 9012 0 1 50
2222 1236 2468 2 6661 6662 1 300
2333 -1 3721 3 6661 6662 6663 1 100
```

### Sample Output:

```out
3
8888 1 1.000 1000.000
0001 15 0.600 100.000
5551 4 0.750 100.000
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct DATA {
	int id, fid, mid, estate, area, members = 0;
};
struct node {
	int id, TotalMembers;
	double avrEstate, avrArea;
	bool isExist = false;
}ans[10010];
int father[10010];
bool visit[10010] = { false };
int findFather(int x) {
	int fa = x;
	while (fa != father[fa]) fa = father[fa];
	int upfa = x;
	while (upfa != father[upfa]) {
		upfa = father[upfa];
		father[x] = fa;
		x = upfa;
	}
	return fa;
}
void Union(int a, int b) {
	int fa = findFather(a);
	int fb = findFather(b);
	if (fa > fb) father[fa] = fb;//敲黑板！！
	if (fa < fb) father[fb] = fa;
}
bool cmp(node a, node b) {
	return a.avrArea != b.avrArea ? a.avrArea > b.avrArea:a.id < b.id;
}
int main() {
	int n, k, childID;
	vector<DATA> Data;
	scanf("%d", &n);
	for (int i = 0; i < 10010; i++)
		father[i] = i;
	Data.resize(n);
	for (int i = 0; i < n; i++) {
		scanf("%d%d%d%d", &Data[i].id, &Data[i].fid, &Data[i].mid, &k);
		if (visit[Data[i].id] == false)
		{
			Data[i].members++; visit[Data[i].id] = true;
		};
		//柳神的data不是用id做索引而是以下标为索引！！体会一下
		if (Data[i].fid != -1) {
			Union(Data[i].id, Data[i].fid);
			if (visit[Data[i].fid] == false)
			{
				Data[i].members++; visit[Data[i].fid] = true;
			};
			//会重复计算！！没有想到
		}
		if (Data[i].mid != -1) {
			Union(Data[i].id, Data[i].mid);
			if (visit[Data[i].mid] == false)
			{
				Data[i].members++; visit[Data[i].mid] = true;
			};
		}
		for (int j = 0; j < k; j++) {
			scanf("%d", &childID);
			Union(Data[i].id, childID);
			if (visit[childID] == false)
			{
				Data[i].members++; visit[childID] = true;
			};
		}
		scanf("%d%d", &Data[i].estate, &Data[i].area);
	}
	int cnt = 0;
	for (int i = 0; i < n; i++) {
		ans[findFather(Data[i].id)].id = findFather(Data[i].id);
		ans[findFather(Data[i].id)].TotalMembers += Data[i].members;
		ans[findFather(Data[i].id)].avrArea += Data[i].area;//+=没写
		ans[findFather(Data[i].id)].avrEstate += Data[i].estate;
		ans[findFather(Data[i].id)].isExist = true;
	}
	for (int i = 0; i < 10010; i++) {
		if (ans[i].isExist == true) {
			cnt++;
			ans[i].avrArea = (double)ans[i].avrArea / (double)ans[i].TotalMembers;
			ans[i].avrEstate = (double)ans[i].avrEstate / (double)ans[i].TotalMembers;
		}
	}
	sort(ans, ans + 10010, cmp);
	printf("%d\n", cnt);
	for (int i = 0; i < cnt; i++)
		printf("%04d %d %.3lf %.3lf\n", ans[i].id, ans[i].TotalMembers, \
			ans[i].avrEstate, ans[i].avrArea);
	return 0;
}

//我所遇到的问题：
/*
1.如何实现集合的表示？以及如何让有交集的集合合并？
还有如何让集合和其他信息房产挂钩？
使用并查集：难以实现交集则合并且根唯一
思路是先合并一组数据 然后判断这个家族是否有成员是其他
（判断有没有父亲再合并这个方法真的蠢爆了）
（因为father仅仅是第一个不具有什么特征，所以担心father会改来改去 同一集合）
集合的一部分（写个flag） 如果是则和那个集合合并

*/
/*
用数组分割功能
常用于统计
一个接受数据
一个分析数据/处理数据
一个装载结果
*/
/*
（利用特征值来规划 数据结构）
利用题目的特征值处理并查集的根节点，可以达到出现就并的效果

*/
~~~

# 1098 Insertion or Heap Sort (25 分)（堆）

According to Wikipedia:

**Insertion sort** iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.

**Heap sort** divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.

Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤100). Then in the next line, *N* integers are given as the initial sequence. The last line contains the partially sorted sequence of the *N* numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in the first line either "Insertion Sort" or "Heap Sort" to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
```

### Sample Output 1:

```out
Insertion Sort
1 2 3 5 7 8 9 4 6 0
```

### Sample Input 2:

```
10
3 1 2 8 7 5 9 4 6 0
6 4 5 1 0 3 2 7 8 9
```

### Sample Output 2:

```
Heap Sort
5 4 3 1 0 2 6 7 8 9
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
vector<int> initSeq,PartSeq;
void downAdjust(int low,int high){
    int faPos=low,childPos=2*low;
    while(childPos<=high){
        if(childPos+1<=high&&PartSeq[childPos+1]>PartSeq[childPos])
            childPos++;
        if(PartSeq[faPos]<PartSeq[childPos]){
            swap(PartSeq[faPos],PartSeq[childPos]);
            faPos=childPos;
            childPos=faPos*2;
        }
        else break;
    }
}
int main(){
    int n;
    scanf("%d",&n);
    initSeq.resize(n+1);PartSeq.resize(n+1);
    for(int i=1;i<=n;i++) scanf("%d",&initSeq[i]);
    for(int i=1;i<=n;i++) scanf("%d",&PartSeq[i]);
    int OrderedEnd=2;
    while(OrderedEnd<=n&&PartSeq[OrderedEnd]>=PartSeq[OrderedEnd-1]) OrderedEnd++;
    //这里没有填 OrderedEnd<=n
    int i=OrderedEnd;
    while(i<=n&&initSeq[i]==PartSeq[i]) {i++;}
    //没有填上i的终止边界
    if(i==n+1){
        printf("Insertion Sort\n");
        sort(PartSeq.begin()+1,PartSeq.begin()+OrderedEnd+1);
    }else{
        printf("Heap Sort\n");
        int unOrderPos=n;
        while(PartSeq[unOrderPos]>=PartSeq[1]) unOrderPos--;
        swap(PartSeq[1],PartSeq[unOrderPos]);//忘记写了 这里要交换下面要-1
        downAdjust(1,unOrderPos-1);
    }
    for(int i=1;i<=n;i++)
        printf("%d%c",PartSeq[i],i==n?'\n':' ');
    return 0;
}
//如何鉴别插入排序
//如何寻找heap从哪里开始排序

~~~

# 1034 Head of a Gang (30 分)（图的遍历DFS）



One way that the police finds the head of a gang is to check people's phone calls. If there is a phone call between *A* and *B*, we say that *A* and *B* is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A "Gang" is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threthold *K*. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.

### Input Specification:

Each input file contains one test case. For each case, the first line contains two positive numbers *N* and *K* (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then *N*lines follow, each in the following format:

```
Name1 Name2 Time
```

where `Name1` and `Name2` are the names of people at the two ends of the call, and `Time` is the length of the call. A name is a string of three capital letters chosen from `A`-`Z`. A time length is a positive integer which is no more than 1000 minutes.

### Output Specification:

For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.

### Sample Input 1:

```in
8 59
AAA BBB 10
BBB AAA 20
AAA CCC 40
DDD EEE 5
EEE DDD 70
FFF GGG 30
GGG HHH 20
HHH FFF 10
```

### Sample Output 1:

```out
2
AAA 3
GGG 3
```

### Sample Input 2:

```in
8 70
AAA BBB 10
BBB AAA 20
AAA CCC 40
DDD EEE 5
EEE DDD 70
FFF GGG 30
GGG HHH 20
HHH FFF 10
```

### Sample Output 2:

```out
0
```

~~~C++
#pragma warning(disable:4996)
#include<iostream>
#include<cstdio>
#include<vector>
#include<string>
#include<map>
#include<algorithm>
#define MAXN 2010
using namespace std;
int G[MAXN][MAXN] = { 0 }; int n, k, numPerson = 0, cntClusters = 0;
int TotalTalkTime = 0, headID, headTalkTime = -1;
bool visit[MAXN] = { false };
bool EdgeVisit[MAXN][MAXN] = { false };
map<string, int> str2int;
map<int, string> int2str;
struct node {
	string head; int clusterNum;
	node(string _head, int _clusterNum) {
		head = _head; clusterNum = _clusterNum;
	}
};
vector<node> ans;
int getID(string s) {
	if (str2int.find(s) == str2int.end()) {
		str2int[s] = numPerson;
		int2str[numPerson] = s;
		numPerson++;
		int2str[numPerson] = s;
		return numPerson - 1;
	}
	else {
		return str2int[s];
	}
}
string getName(int ID) {
	return int2str[ID];
}
void DFS(int vertex) {
	int TalkTimeWithOthers = 0;
//	if (visit[vertex] == false) {递归冗余代码类：
		visit[vertex] = true;//因为要计算cntclusters
		cntClusters++;//怕重复所以又判断了一下 实际上没必要
//	}//递归的进入条件就是未被访问
	for (int i = 0; i < MAXN; i++) {
		if (G[vertex][i] != 0 && visit[i] == false)
			DFS(i);//顶点未被访问就DFS
		if (G[vertex][i] != 0) {
			if (EdgeVisit[vertex][i] == false) {
				EdgeVisit[vertex][i] = true;
				TotalTalkTime += G[vertex][i];
			}
			TalkTimeWithOthers += G[vertex][i];
		}
		if (G[i][vertex] != 0) {
			if (EdgeVisit[i][vertex] == false) {
				EdgeVisit[i][vertex] = true;
				TotalTalkTime += G[i][vertex];
			}
			TalkTimeWithOthers += G[i][vertex];
		}
		//TotalTalkTime += TalkTimeWithOthers;这句不该加
		//DFS中变量的累加问题
	}//totaltalktime应该是被定义为所有的边权之和，talktimewithothers应该是totaltalktime的子集，所以这里要加上去
	//totaltalktime是未被访问edge的累加，而talktimewithothers没有这个限制 所以+=后会造成重复
	//全局量和局部量的相加要考虑重合问题
	//变量是个瓶子 值是里面的水搞清楚有没有重复装水
	if (TalkTimeWithOthers > headTalkTime) {
		headTalkTime = TalkTimeWithOthers;
		headID = vertex;
	}
}
void DFSTravel() {
	for (int i = 0; i < MAXN; i++) {
		if (visit[i] == false) {
			DFS(i);
			if (TotalTalkTime > k && cntClusters>2)
				ans.push_back(node(getName(headID), cntClusters));
			headTalkTime = -1;
			TotalTalkTime = 0;
			cntClusters = 0;
		}
	}
}
bool cmp(node a, node b) {
	return a.head < b.head;
}
int main() {
	scanf("%d%d", &n, &k);
	string strA, strB; int weight;
	strA.resize(3); strB.resize(3);
	for (int i = 0; i < n; i++) {
		scanf("%s%s%d", &strA[0], &strB[0], &weight);
		G[getID(strA)][getID(strB)] = weight;
	}
	DFSTravel();
	printf("%d\n", ans.size());
	sort(ans.begin(), ans.end(),cmp);
	for (int i = 0; i < (int)ans.size(); i++) {
		printf("%s %d\n", ans[i].head.c_str(), ans[i].clusterNum);
	}
	return 0;
}
//柳神的优秀思想：（数组的正确使用方法）
//我们需要的是每个clusters的head的ID，为了实现这个目的我们需要统计、
//TalkTimeWithOthers而这个不一定在DFS里面做
//由于所需要的参量有每个顶点的所有临边权和
//因为对于输入格式而言 输入的就是两个顶点之间的权和情况
//只要累加个个顶点的通话权和就可以很方便的计算出TalkTimeWithOthers

//map的奇妙使用方法：
//ans只要求键值是string和int类型
//map会把键值从小到大安排好
//所以使用map代替node作为ans的类型会使得
//我们不需要排序就可以得到结果
//记得不要用printf用cout！！不然用%s会得到乱码

//做个参考;
//晴神和柳神为了统计每个cluster的TotalTalkTime
//在访问了边之后就把他清0，免去了设置visitedEdge的麻烦
//如果不想设置visit而且在后续的工作中不用用到这个节点可以
//想办法让这个变量失效 不进入if语句内

//做个参考：
//柳神在统计数据时（如TotalTalkTime—）时把这玩意当成一个
//输入参数传入引用
//实际上就是利用输入参数来实现传输返回值
//这样可以不用设置全局变量
//也不需要在出来连通分量后对全局变量进行清0
//只需要给个变量让他传入即可

//递归统计问题
//有两种方法：
//1、将统计变量作为参数传入函数 2、设置全局变量 3、返回值统计（高度）
//注意统计值的统计条件
//返回值统计：图的遍历是遍历点 但遍历条件是边
//点本身不带什么权值信息 而边带着
//DFS是点的DFS返回的是点的属性
//如果需要返回所有点入度出度和
//我们需要统计 自己的度 和别人的度 再返回度之和
//返回值大多是这个模板
~~~





# 1076 Forwards on Weibo (30 分)（图的遍历BFS）



Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only *L* levels of indirect followers are counted.

### Input Specification:

Each input file contains one test case. For each case, the first line contains 2 positive integers: *N* (≤1000), the number of users; and *L* (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to *N*. Then *N* lines follow, each in the format:

```
M[i] user_list[i]
```

where `M[i]` (≤100) is the total number of people that `user[i]` follows; and `user_list[i]` is a list of the `M[i]` users that followed by `user[i]`. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.

Then finally a positive *K* is given, followed by *K* `UserID`'s for query.

### Output Specification:

For each `UserID`, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only *L*levels of indirect followers are counted.

### Sample Input:

```in
7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6
```

### Sample Output:

```out
4
5
```

~~~C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
const int MAXV=1010;
vector<int> Adj[MAXV];int N,L,ansIndex=0;
vector<int> ans;
void BFS(int poster){
    bool OnceInQueue[MAXV]={false};
    queue<int> q;int level=0,levelEnd;
    q.push(poster);
    levelEnd=poster;
    OnceInQueue[poster]=true;
    while(!q.empty()){
        int frontElment=q.front();
        q.pop();
        for(int i=0;i<(int)Adj[frontElment].size()&&level<L;i++){
            if(OnceInQueue[Adj[frontElment][i]]==false){
                q.push(Adj[frontElment][i]);
                OnceInQueue[Adj[frontElment][i]]=true;
                ans[ansIndex]++;
            }
        }
        if(frontElment==levelEnd){
            level++;
            levelEnd=q.back();
        }
    }
}
int main(){
    int userListI,FollowedBy;
    scanf("%d%d",&N,&L);
    for(int i=1;i<=N;i++){
        scanf("%d",&userListI);
        for(int j=0;j<userListI;j++){
            scanf("%d",&FollowedBy);
            Adj[FollowedBy].push_back(i);
        }
    }
    int TestCasesNum;vector<int> TestCases;
    scanf("%d",&TestCasesNum);
    TestCases.resize(TestCasesNum);ans.resize(TestCasesNum);
    for(int i=0;i<TestCasesNum;i++){
        scanf("%d",&TestCases[i]);
        BFS(TestCases[i]);
        ansIndex++;
    }
        for(int i=0;i<(int)ans.size();i++)
        printf("%d\n",ans[i]);
    return 0;
}
//第一次code失败

//level处判断失误应该是<
//level 在判断代码的后面更新具有滞后性所以
//应该用< 使得滞后值 不再执行滞后+1的操作

//level写错了
//1、level不是进入一次for就加一层（对根节点是这样的）
//但是对于非根节点 这个是有问题的 根节点会有多个子节点
//子节点又有可能有子子节点，当子节点遍历时，会导致level++
//这时已经脱离本意
//2、BFS是层序遍历 但是for不代表一层for负责把子节点加入队列中
//某种意义上for（BFS while循环中的for循环）是dfs
//或者说带for的遍历都是种DFS

//确定层序 level 的办法
//1、设置levelend到达levelend时level++(不熟练）
//2、设置node 增加layer 进入一次就把layer+1

~~~



# 1013 Battle Over Cities (25 分)（图的遍历+连通分量）

It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.

For example, if we have 3 cities and 2 highways connecting *c**i**t**y*1-*c**i**t**y*2 and *c**i**t**y*1-*c**i**t**y*3. Then if *c**i**t**y*1 is occupied by the enemy, we must have 1 highway repaired, that is the highway *c**i**t**y*2-*c**i**t**y*3.

### Input Specification:

Each input file contains one test case. Each case starts with a line containing 3 numbers *N* (<1000), *M* and *K*, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then *M* lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to *N*. Finally there is a line containing *K*numbers, which represent the cities we concern.

### Output Specification:

For each of the *K* cities, output in a line the number of highways need to be repaired if that city is lost.

### Sample Input:

```in
3 2 3
1 2
1 3
1 2 3
```

### Sample Output:

```out
1
0
0
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int MAXV=1010;
int G[MAXV][MAXV]={0};
bool VertexVisited[MAXV]={false};
void DFS(int index,bool *VertexVisited){
    VertexVisited[index]=true;//不熟练
    for(int i=1;i<MAXV;i++){
        if(G[index][i]!=0&&VertexVisited[i]==false){
                //放在了这里导致判断失误1-3 3-1 都被判断了
            DFS(i,VertexVisited);//dfs图要思考一会要干什么
        //这里写成G[index][i]了，没有搞清楚传入的是什么
        }
    }
}
int main(){
    int n,m,k,cityA,cityB;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<m;i++){
        scanf("%d%d",&cityA,&cityB);
        G[cityA][cityB]=1;
        G[cityB][cityA]=1;
    }
    vector<int> ans;int ConcernedCities;
    ans.resize(k);
    for(int i=0;i<k;i++){
        scanf("%d",&ConcernedCities);
        fill(VertexVisited,VertexVisited+MAXV,false);
        VertexVisited[ConcernedCities]=true;//ConcernedCities[i]写成了i
        int cntConnectedComponent=0;
        for(int j=1;j<=n;j++){
            if(VertexVisited[j]==false){
                DFS(j,VertexVisited);
                cntConnectedComponent++;
            }
        }
        ans[i]=cntConnectedComponent-1;//这里应该再减去1
    }
    for(int i=0;i<k;i++)
        printf("%d\n",ans[i]);
    return 0;
}
//第一次code 失败
//没有体会到题目想考连通分量的计数
//问题？for循环第一次判断失败就会退出吗
~~~



# **1021** **Deepest Root** **(25** **分**)（图的遍历+连通分量计数）

A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called **the deepest root**.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤104) which is the number of nodes, and hence the nodes are numbered from 1 to *N*. Then *N*−1 lines follow, each describes an edge by given the two adjacent nodes' numbers.

### Output Specification:

For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print `Error: K components`where `K` is the number of connected components in the graph.

### Sample Input 1:

```in
5
1 2
1 3
1 4
2 5
```

### Sample Output 1:

```out
3
4
5
```

### Sample Input 2:

```in
5
1 3
1 4
2 5
3 4
```

### Sample Output 2:

```out
Error: 2 components
```

~~~C++
#include<iostream>
#include<set>
#include<vector>
#include<algorithm>
using namespace std;
const int MAXV = 10010;
vector<int> Adj[MAXV]; int MaxDepth = -1,n;
set<int> ans;
bool visited[MAXV] = { false };
void DFS(int u, int depth) {
	visited[u] = true;
	if (depth == MaxDepth) ans.insert(u);
	if (depth > MaxDepth) {
		MaxDepth = depth;
		ans.clear();
		ans.insert(u);
	}
	for (int i = 0; i < (int)Adj[u].size(); i++) {
		if (visited[Adj[u][i]] == false) {
			DFS(Adj[u][i], depth + 1);
		}
	}
}
int  DFSTravel() {
	int cntComponent = 0;
	for (int i = 1; i <= n; i++) {//这里该写maxv-1
		if (visited[i] == false) {
			DFS(i, 0);
			cntComponent++;
		}
	}
	return cntComponent;
}
int main() {
	int edgStart, edgeEnd;
	int i = 0;
	scanf("%d", &n);
	for (int i = 0; i < n - 1; i++) {
		scanf("%d%d", &edgStart, &edgeEnd);
		Adj[edgStart].push_back(edgeEnd);//无向图要强连通
		Adj[edgeEnd].push_back(edgStart);
	}
	int cnt = DFSTravel();
	if (cnt != 1) {
		printf("Error: %d components", cnt);
	}
	else {
		int newRoot = *ans.begin();
		//忘了刷新visited
		set<int> oldnode;
		for (auto it = ans.begin(); it != ans.end(); it++)
			oldnode.insert(*it);
		fill(visited, visited + MAXV, false);
		DFS(newRoot, 0);
		for(auto it=oldnode.begin();it!=oldnode.end();it++)
			ans.insert(*it);
		for (auto itt = ans.begin(); itt != ans.end(); itt++)
			printf("%d\n", *itt);
	}
	return 0;
}
//没有意识到自己算法是N2级别的
//图的问题不要通过遍历所有顶点实现
//心虚

//我的思路：
//deepestRoot=》求树的深度，用depth和一个maxdepth来判定=》每个都遍历一下就可以找出来；
/*
知道了先遍历一次再从最长叶可求=》写dfs=》需要根节点和depth的对应关系 传入depth
（实际上题目没有要求求根和深度的关系只要求根）=》
怎么实现两次都用一个dfs？（没考虑影响）=》
看到题干以为要判断连通！！就是要判断连通
*/
//仔细分析题干 看题目要求什么！
~~~

