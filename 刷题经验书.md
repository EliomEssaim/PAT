[TOC]

# a1043 Is It a Binary Search Tree (25 分)（二叉搜索树）

A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

If we swap the left and right subtrees of every node, then the resulting tree is called the **Mirror Image** of a BST.

Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤1000). Then *N* integer keys are given in the next line. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first print in a line `YES` if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or `NO` if not. Then if the answer is `YES`, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
8 6 5 7 10 8 11
```

### Sample Output 1:

```out
YES
5 7 6 8 11 10 8
```

### Sample Input 2:

```in
7
8 10 11 8 6 7 5
```

### Sample Output 2:

```out
YES
11 8 10 7 5 6 8
```

### Sample Input 3:

```in
7
8 6 8 5 10 9 11
```

### Sample Output 3:

```out
NO
```

~~~C++
#include<iostream>
#include<vector>
#include <algorithm>
using namespace std;
vector<int> pre,post;bool isMirror=false;
void PostOrder(int start,int eend){
    if(start>eend) return ;
    int root=start,leftEnd=eend,RightStart=start+1;
    if(!isMirror){
        while(leftEnd>=root+1&&pre[root]<=pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]>pre[RightStart]) RightStart++;
    }
    else{//修改耗时
        while(leftEnd>=root+1&&pre[root]>pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]<=pre[RightStart]) RightStart++;
    }
    if(RightStart-leftEnd!=1) return;//耗时部分临界点的处理
    PostOrder(root+1,leftEnd);
    PostOrder(RightStart,eend);
    post.push_back(pre[root]);
}
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    for(int i=0;i<n;i++)
        scanf("%d",&pre[i]);
    PostOrder(0,n-1);
    if((int)post.size()<n){
        isMirror=true;
        post.clear();//忘了清理；
        PostOrder(0,n-1);
    }
    if((int)post.size()<n) printf("NO\n");
    else {
        printf("YES\n");
        for(int i=0;i<n;i++)
            printf("%d%c",post[i],i==n-1?'\n':' ');
    }
    return 0;
}
//要给定搜索序列的开始和结束为位置，给出正常的终止条件给出异常的判断
//柳神的思路：给出了一个重要的二叉树思想，递归的处理序列，在什么位置处理就是什么位置的遍历十分简洁高效

~~~



# **1090** **Highest Price in Supply Chain** **(25** **分**)（树的遍历）

A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.

Starting from one root supplier, everyone on the chain buys products from one's supplier in a price *P* and sell or distribute them in a price that is *r*% higher than *P*. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.

Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers.

### Input Specification:

Each input file contains one test case. For each case, The first line contains three positive numbers: *N* (≤105), the total number of the members in the supply chain (and hence they are numbered from 0 to *N*−1); *P*, the price given by the root supplier; and *r*, the percentage rate of price increment for each distributor or retailer. Then the next line contains *N* numbers, each number *S**i* is the index of the supplier for the *i*-th member. *S**r**o**o**t* for the root supplier is defined to be −1. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed 1010.

### Sample Input:

```in
9 1.80 1.00
1 5 4 4 -1 4 5 3 6
```

### Sample Output:

```out
1.85 2
```

~~~c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
int maxDepth=0,num=1;
vector<int> tree[100010];
void dfs(int index,int d){
    if(tree[index].empty()){
        if(d>maxDepth){
            maxDepth=d;
            num=1;
        }else if(d==maxDepth){
            num++;
        }
    }
    for(int i=0;i<(int)tree[index].size();i++){
        dfs(tree[index][i],d+1);
    }
    return;
}
double p,r,maxPrice;
int main(){
    int n;
    scanf("%d%lf%lf",&n,&p,&r);
    r/=100;int root=0,tmp;
    for(int i=0;i<n;i++){
        scanf("%d",&tmp);//不熟悉下标和值的关系
        if(tmp==-1) root=i;
        else tree[tmp].push_back(i);
    }
    dfs(root,0);
    maxPrice=p*pow(1+r,maxDepth);
    printf("%.2f %d",maxPrice,num);

    return 0;
}
~~~



# 1119 Pre- and Post-order Traversals (30 分)（二叉树的遍历）



Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.

Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first printf in a line `Yes` if the tree is unique, or `No` if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
```

### Sample Output 1:

```out
Yes
2 1 6 4 7 3 5
```

### Sample Input 2:

```in
4
1 2 3 4
2 4 3 1
```

### Sample Output 2:

```out
No
2 1 3 4
```



```C++
#include<iostream>
#include<vector>
using namespace std;
vector<int> pre,post,in;
bool isUnique=true;int inPos=0;
void inOrder(int root,int start,int eend){
    if(start>eend) return;
    int leftEnd=eend;
    while(pre[root+1]!=post[leftEnd]&&leftEnd!=-1) leftEnd--;
    int leftEndSize=leftEnd-start+1;
    if((start-eend+1)%2==0) isUnique=false;
    inOrder(root+1,start,leftEnd);
    in[inPos++]=pre[root];
    if(leftEnd!=-1) inOrder(root+1+leftEndSize,leftEnd+1,eend-1);
    else inOrder(root+1+leftEndSize,start+1,eend-1);//这里写错了逻辑不清楚，
}
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    post.resize(n);
    in.resize(n);
    for(int i=0;i<n;i++) scanf("%d",&pre[i]);
    for(int i=0;i<n;i++) scanf("%d",&post[i]);
    inOrder(0,0,n-1);
    if(isUnique) printf("Yes\n");
    else printf("No\n");
    for(int i=0;i<n;i++)
        printf("%d%c",in[i],i==n-1?'\n':' ');
    return 0;
}
/*******************************************/
/*
逻辑不清楚，首先start和end谁是谁的没搞清楚
应该一个序列提供跟节点一个序列利用自己去锁定下一个根节点；同时更新一下自己的查找范围。
此外本次不同于普通的中序遍历，会出现特殊结果leftEnd=-1；的情况，没有充分考虑=-1的情况下
对后续的程序的影响（例如右子树的后序的锁定范围会出现变化）

逻辑想的慢：
正常：第一次做前后序转中序；难免会对下一次取值生疏
但是下次可以考量一下什么函数要做什么，这个变量的意义
如root start eend的意义搞清楚后就不会有模糊的地方了。

模板改进题：
如果出现了新的值要考虑对原有模板的代码的影响

学习方式：
搞清楚模板函数各个参量的意义，改变他会有造成什么影响

调试窗口的调用：
调试-》调试窗口-》监视
调试-》调试窗口-》调用栈
*/
/********************************************/


```

# 1114 Family Property (25 分)（并查集）



This time, you are supposed to help us collect the data for family-owned property. Given each person's family members, and the estate（房产）info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤1000). Then *N* lines follow, each gives the infomation of a person who owns estate in the format:

```
ID` `Father` `Mother` *k* *C**h**i**l**d*1⋯*C**h**i**l**d**k* *M**e**s**t**a**t**e* `Area
```

where `ID` is a unique 4-digit identification number for each person; `Father` and `Mother` are the `ID`'s of this person's parents (if a parent has passed away, `-1` will be given instead); *k* (0≤*k*≤5) is the number of children of this person; *C**h**i**l**d**i*'s are the `ID`'s of his/her children; *M**e**s**t**a**t**e* is the total number of sets of the real estate under his/her name; and `Area` is the total area of his/her estate.

### Output Specification:

For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format:

`ID` `M` *A**V**G**s**e**t**s* *A**V**G**a**r**e**a*

where `ID` is the smallest ID in the family; `M` is the total number of family members; *A**V**G**s**e**t**s* is the average number of sets of their real estate; and *A**V**G**a**r**e**a* is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID's if there is a tie.

### Sample Input:

```in
10
6666 5551 5552 1 7777 1 100
1234 5678 9012 1 0002 2 300
8888 -1 -1 0 1 1000
2468 0001 0004 1 2222 1 500
7777 6666 -1 0 2 300
3721 -1 -1 1 2333 2 150
9012 -1 -1 3 1236 1235 1234 1 100
1235 5678 9012 0 1 50
2222 1236 2468 2 6661 6662 1 300
2333 -1 3721 3 6661 6662 6663 1 100
```

### Sample Output:

```out
3
8888 1 1.000 1000.000
0001 15 0.600 100.000
5551 4 0.750 100.000
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct DATA {
	int id, fid, mid, estate, area, members = 0;
};
struct node {
	int id, TotalMembers;
	double avrEstate, avrArea;
	bool isExist = false;
}ans[10010];
int father[10010];
bool visit[10010] = { false };
int findFather(int x) {
	int fa = x;
	while (fa != father[fa]) fa = father[fa];
	int upfa = x;
	while (upfa != father[upfa]) {
		upfa = father[upfa];
		father[x] = fa;
		x = upfa;
	}
	return fa;
}
void Union(int a, int b) {
	int fa = findFather(a);
	int fb = findFather(b);
	if (fa > fb) father[fa] = fb;//敲黑板！！
	if (fa < fb) father[fb] = fa;
}
bool cmp(node a, node b) {
	return a.avrArea != b.avrArea ? a.avrArea > b.avrArea:a.id < b.id;
}
int main() {
	int n, k, childID;
	vector<DATA> Data;
	scanf("%d", &n);
	for (int i = 0; i < 10010; i++)
		father[i] = i;
	Data.resize(n);
	for (int i = 0; i < n; i++) {
		scanf("%d%d%d%d", &Data[i].id, &Data[i].fid, &Data[i].mid, &k);
		if (visit[Data[i].id] == false)
		{
			Data[i].members++; visit[Data[i].id] = true;
		};
		//柳神的data不是用id做索引而是以下标为索引！！体会一下
		if (Data[i].fid != -1) {
			Union(Data[i].id, Data[i].fid);
			if (visit[Data[i].fid] == false)
			{
				Data[i].members++; visit[Data[i].fid] = true;
			};
			//会重复计算！！没有想到
		}
		if (Data[i].mid != -1) {
			Union(Data[i].id, Data[i].mid);
			if (visit[Data[i].mid] == false)
			{
				Data[i].members++; visit[Data[i].mid] = true;
			};
		}
		for (int j = 0; j < k; j++) {
			scanf("%d", &childID);
			Union(Data[i].id, childID);
			if (visit[childID] == false)
			{
				Data[i].members++; visit[childID] = true;
			};
		}
		scanf("%d%d", &Data[i].estate, &Data[i].area);
	}
	int cnt = 0;
	for (int i = 0; i < n; i++) {
		ans[findFather(Data[i].id)].id = findFather(Data[i].id);
		ans[findFather(Data[i].id)].TotalMembers += Data[i].members;
		ans[findFather(Data[i].id)].avrArea += Data[i].area;//+=没写
		ans[findFather(Data[i].id)].avrEstate += Data[i].estate;
		ans[findFather(Data[i].id)].isExist = true;
	}
	for (int i = 0; i < 10010; i++) {
		if (ans[i].isExist == true) {
			cnt++;
			ans[i].avrArea = (double)ans[i].avrArea / (double)ans[i].TotalMembers;
			ans[i].avrEstate = (double)ans[i].avrEstate / (double)ans[i].TotalMembers;
		}
	}
	sort(ans, ans + 10010, cmp);
	printf("%d\n", cnt);
	for (int i = 0; i < cnt; i++)
		printf("%04d %d %.3lf %.3lf\n", ans[i].id, ans[i].TotalMembers, \
			ans[i].avrEstate, ans[i].avrArea);
	return 0;
}

//我所遇到的问题：
/*
1.如何实现集合的表示？以及如何让有交集的集合合并？
还有如何让集合和其他信息房产挂钩？
使用并查集：难以实现交集则合并且根唯一
思路是先合并一组数据 然后判断这个家族是否有成员是其他
（判断有没有父亲再合并这个方法真的蠢爆了）
（因为father仅仅是第一个不具有什么特征，所以担心father会改来改去 同一集合）
集合的一部分（写个flag） 如果是则和那个集合合并

*/
/*
用数组分割功能
常用于统计
一个接受数据
一个分析数据/处理数据
一个装载结果
*/
/*
（利用特征值来规划 数据结构）
利用题目的特征值处理并查集的根节点，可以达到出现就并的效果

*/
~~~

# 1098 Insertion or Heap Sort (25 分)（堆）

According to Wikipedia:

**Insertion sort** iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.

**Heap sort** divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.

Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤100). Then in the next line, *N* integers are given as the initial sequence. The last line contains the partially sorted sequence of the *N* numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in the first line either "Insertion Sort" or "Heap Sort" to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
```

### Sample Output 1:

```out
Insertion Sort
1 2 3 5 7 8 9 4 6 0
```

### Sample Input 2:

```
10
3 1 2 8 7 5 9 4 6 0
6 4 5 1 0 3 2 7 8 9
```

### Sample Output 2:

```
Heap Sort
5 4 3 1 0 2 6 7 8 9
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
vector<int> initSeq,PartSeq;
void downAdjust(int low,int high){
    int faPos=low,childPos=2*low;
    while(childPos<=high){
        if(childPos+1<=high&&PartSeq[childPos+1]>PartSeq[childPos])
            childPos++;
        if(PartSeq[faPos]<PartSeq[childPos]){
            swap(PartSeq[faPos],PartSeq[childPos]);
            faPos=childPos;
            childPos=faPos*2;
        }
        else break;
    }
}
int main(){
    int n;
    scanf("%d",&n);
    initSeq.resize(n+1);PartSeq.resize(n+1);
    for(int i=1;i<=n;i++) scanf("%d",&initSeq[i]);
    for(int i=1;i<=n;i++) scanf("%d",&PartSeq[i]);
    int OrderedEnd=2;
    while(OrderedEnd<=n&&PartSeq[OrderedEnd]>=PartSeq[OrderedEnd-1]) OrderedEnd++;
    //这里没有填 OrderedEnd<=n
    int i=OrderedEnd;
    while(i<=n&&initSeq[i]==PartSeq[i]) {i++;}
    //没有填上i的终止边界
    if(i==n+1){
        printf("Insertion Sort\n");
        sort(PartSeq.begin()+1,PartSeq.begin()+OrderedEnd+1);
    }else{
        printf("Heap Sort\n");
        int unOrderPos=n;
        while(PartSeq[unOrderPos]>=PartSeq[1]) unOrderPos--;
        swap(PartSeq[1],PartSeq[unOrderPos]);//忘记写了 这里要交换下面要-1
        downAdjust(1,unOrderPos-1);
    }
    for(int i=1;i<=n;i++)
        printf("%d%c",PartSeq[i],i==n?'\n':' ');
    return 0;
}
//如何鉴别插入排序
//如何寻找heap从哪里开始排序

~~~

# 1034 Head of a Gang (30 分)（图的遍历DFS）



One way that the police finds the head of a gang is to check people's phone calls. If there is a phone call between *A* and *B*, we say that *A* and *B* is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A "Gang" is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threthold *K*. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.

### Input Specification:

Each input file contains one test case. For each case, the first line contains two positive numbers *N* and *K* (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then *N*lines follow, each in the following format:

```
Name1 Name2 Time
```

where `Name1` and `Name2` are the names of people at the two ends of the call, and `Time` is the length of the call. A name is a string of three capital letters chosen from `A`-`Z`. A time length is a positive integer which is no more than 1000 minutes.

### Output Specification:

For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.

### Sample Input 1:

```in
8 59
AAA BBB 10
BBB AAA 20
AAA CCC 40
DDD EEE 5
EEE DDD 70
FFF GGG 30
GGG HHH 20
HHH FFF 10
```

### Sample Output 1:

```out
2
AAA 3
GGG 3
```

### Sample Input 2:

```in
8 70
AAA BBB 10
BBB AAA 20
AAA CCC 40
DDD EEE 5
EEE DDD 70
FFF GGG 30
GGG HHH 20
HHH FFF 10
```

### Sample Output 2:

```out
0
```

~~~C++
#pragma warning(disable:4996)
#include<iostream>
#include<cstdio>
#include<vector>
#include<string>
#include<map>
#include<algorithm>
#define MAXN 2010
using namespace std;
int G[MAXN][MAXN] = { 0 }; int n, k, numPerson = 0, cntClusters = 0;
int TotalTalkTime = 0, headID, headTalkTime = -1;
bool visit[MAXN] = { false };
bool EdgeVisit[MAXN][MAXN] = { false };
map<string, int> str2int;
map<int, string> int2str;
struct node {
	string head; int clusterNum;
	node(string _head, int _clusterNum) {
		head = _head; clusterNum = _clusterNum;
	}
};
vector<node> ans;
int getID(string s) {
	if (str2int.find(s) == str2int.end()) {
		str2int[s] = numPerson;
		int2str[numPerson] = s;
		numPerson++;
		int2str[numPerson] = s;
		return numPerson - 1;
	}
	else {
		return str2int[s];
	}
}
string getName(int ID) {
	return int2str[ID];
}
void DFS(int vertex) {
	int TalkTimeWithOthers = 0;
//	if (visit[vertex] == false) {递归冗余代码类：
		visit[vertex] = true;//因为要计算cntclusters
		cntClusters++;//怕重复所以又判断了一下 实际上没必要
//	}//递归的进入条件就是未被访问
	for (int i = 0; i < MAXN; i++) {
		if (G[vertex][i] != 0 && visit[i] == false)
			DFS(i);//顶点未被访问就DFS
		if (G[vertex][i] != 0) {
			if (EdgeVisit[vertex][i] == false) {
				EdgeVisit[vertex][i] = true;
				TotalTalkTime += G[vertex][i];
			}
			TalkTimeWithOthers += G[vertex][i];
		}
		if (G[i][vertex] != 0) {
			if (EdgeVisit[i][vertex] == false) {
				EdgeVisit[i][vertex] = true;
				TotalTalkTime += G[i][vertex];
			}
			TalkTimeWithOthers += G[i][vertex];
		}
		//TotalTalkTime += TalkTimeWithOthers;这句不该加
		//DFS中变量的累加问题
	}//totaltalktime应该是被定义为所有的边权之和，talktimewithothers应该是totaltalktime的子集，所以这里要加上去
	//totaltalktime是未被访问edge的累加，而talktimewithothers没有这个限制 所以+=后会造成重复
	//全局量和局部量的相加要考虑重合问题
	//变量是个瓶子 值是里面的水搞清楚有没有重复装水
	if (TalkTimeWithOthers > headTalkTime) {
		headTalkTime = TalkTimeWithOthers;
		headID = vertex;
	}
}
void DFSTravel() {
	for (int i = 0; i < MAXN; i++) {
		if (visit[i] == false) {
			DFS(i);
			if (TotalTalkTime > k && cntClusters>2)
				ans.push_back(node(getName(headID), cntClusters));
			headTalkTime = -1;
			TotalTalkTime = 0;
			cntClusters = 0;
		}
	}
}
bool cmp(node a, node b) {
	return a.head < b.head;
}
int main() {
	scanf("%d%d", &n, &k);
	string strA, strB; int weight;
	strA.resize(3); strB.resize(3);
	for (int i = 0; i < n; i++) {
		scanf("%s%s%d", &strA[0], &strB[0], &weight);
		G[getID(strA)][getID(strB)] = weight;
	}
	DFSTravel();
	printf("%d\n", ans.size());
	sort(ans.begin(), ans.end(),cmp);
	for (int i = 0; i < (int)ans.size(); i++) {
		printf("%s %d\n", ans[i].head.c_str(), ans[i].clusterNum);
	}
	return 0;
}
//柳神的优秀思想：（数组的正确使用方法）
//我们需要的是每个clusters的head的ID，为了实现这个目的我们需要统计、
//TalkTimeWithOthers而这个不一定在DFS里面做
//由于所需要的参量有每个顶点的所有临边权和
//因为对于输入格式而言 输入的就是两个顶点之间的权和情况
//只要累加个个顶点的通话权和就可以很方便的计算出TalkTimeWithOthers

//map的奇妙使用方法：
//ans只要求键值是string和int类型
//map会把键值从小到大安排好
//所以使用map代替node作为ans的类型会使得
//我们不需要排序就可以得到结果
//记得不要用printf用cout！！不然用%s会得到乱码

//做个参考;
//晴神和柳神为了统计每个cluster的TotalTalkTime
//在访问了边之后就把他清0，免去了设置visitedEdge的麻烦
//如果不想设置visit而且在后续的工作中不用用到这个节点可以
//想办法让这个变量失效 不进入if语句内

//做个参考：
//柳神在统计数据时（如TotalTalkTime—）时把这玩意当成一个
//输入参数传入引用
//实际上就是利用输入参数来实现传输返回值
//这样可以不用设置全局变量
//也不需要在出来连通分量后对全局变量进行清0
//只需要给个变量让他传入即可

//递归统计问题
//有两种方法：
//1、将统计变量作为参数传入函数 2、设置全局变量 3、返回值统计（高度）
//注意统计值的统计条件
//返回值统计：图的遍历是遍历点 但遍历条件是边
//点本身不带什么权值信息 而边带着
//DFS是点的DFS返回的是点的属性
//如果需要返回所有点入度出度和
//我们需要统计 自己的度 和别人的度 再返回度之和
//返回值大多是这个模板
~~~





# 1076 Forwards on Weibo (30 分)（图的遍历BFS）



Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only *L* levels of indirect followers are counted.

### Input Specification:

Each input file contains one test case. For each case, the first line contains 2 positive integers: *N* (≤1000), the number of users; and *L* (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to *N*. Then *N* lines follow, each in the format:

```
M[i] user_list[i]
```

where `M[i]` (≤100) is the total number of people that `user[i]` follows; and `user_list[i]` is a list of the `M[i]` users that followed by `user[i]`. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.

Then finally a positive *K* is given, followed by *K* `UserID`'s for query.

### Output Specification:

For each `UserID`, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only *L*levels of indirect followers are counted.

### Sample Input:

```in
7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6
```

### Sample Output:

```out
4
5
```

~~~C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
const int MAXV=1010;
vector<int> Adj[MAXV];int N,L,ansIndex=0;
vector<int> ans;
void BFS(int poster){
    bool OnceInQueue[MAXV]={false};
    queue<int> q;int level=0,levelEnd;
    q.push(poster);
    levelEnd=poster;
    OnceInQueue[poster]=true;
    while(!q.empty()){
        int frontElment=q.front();
        q.pop();
        for(int i=0;i<(int)Adj[frontElment].size()&&level<L;i++){
            if(OnceInQueue[Adj[frontElment][i]]==false){
                q.push(Adj[frontElment][i]);
                OnceInQueue[Adj[frontElment][i]]=true;
                ans[ansIndex]++;
            }
        }
        if(frontElment==levelEnd){
            level++;
            levelEnd=q.back();
        }
    }
}
int main(){
    int userListI,FollowedBy;
    scanf("%d%d",&N,&L);
    for(int i=1;i<=N;i++){
        scanf("%d",&userListI);
        for(int j=0;j<userListI;j++){
            scanf("%d",&FollowedBy);
            Adj[FollowedBy].push_back(i);
        }
    }
    int TestCasesNum;vector<int> TestCases;
    scanf("%d",&TestCasesNum);
    TestCases.resize(TestCasesNum);ans.resize(TestCasesNum);
    for(int i=0;i<TestCasesNum;i++){
        scanf("%d",&TestCases[i]);
        BFS(TestCases[i]);
        ansIndex++;
    }
        for(int i=0;i<(int)ans.size();i++)
        printf("%d\n",ans[i]);
    return 0;
}
//第一次code失败

//level处判断失误应该是<
//level 在判断代码的后面更新具有滞后性所以
//应该用< 使得滞后值 不再执行滞后+1的操作

//level写错了
//1、level不是进入一次for就加一层（对根节点是这样的）
//但是对于非根节点 这个是有问题的 根节点会有多个子节点
//子节点又有可能有子子节点，当子节点遍历时，会导致level++
//这时已经脱离本意
//2、BFS是层序遍历 但是for不代表一层for负责把子节点加入队列中
//某种意义上for（BFS while循环中的for循环）是dfs
//或者说带for的遍历都是种DFS

//确定层序 level 的办法
//1、设置levelend到达levelend时level++(不熟练）
//2、设置node 增加layer 进入一次就把layer+1

~~~



# 1013 Battle Over Cities (25 分)（图的遍历+连通分量）

It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.

For example, if we have 3 cities and 2 highways connecting *c**i**t**y*1-*c**i**t**y*2 and *c**i**t**y*1-*c**i**t**y*3. Then if *c**i**t**y*1 is occupied by the enemy, we must have 1 highway repaired, that is the highway *c**i**t**y*2-*c**i**t**y*3.

### Input Specification:

Each input file contains one test case. Each case starts with a line containing 3 numbers *N* (<1000), *M* and *K*, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then *M* lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to *N*. Finally there is a line containing *K*numbers, which represent the cities we concern.

### Output Specification:

For each of the *K* cities, output in a line the number of highways need to be repaired if that city is lost.

### Sample Input:

```in
3 2 3
1 2
1 3
1 2 3
```

### Sample Output:

```out
1
0
0
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int MAXV=1010;
int G[MAXV][MAXV]={0};
bool VertexVisited[MAXV]={false};
void DFS(int index,bool *VertexVisited){
    VertexVisited[index]=true;//不熟练
    for(int i=1;i<MAXV;i++){
        if(G[index][i]!=0&&VertexVisited[i]==false){
                //放在了这里导致判断失误1-3 3-1 都被判断了
            DFS(i,VertexVisited);//dfs图要思考一会要干什么
        //这里写成G[index][i]了，没有搞清楚传入的是什么
        }
    }
}
int main(){
    int n,m,k,cityA,cityB;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<m;i++){
        scanf("%d%d",&cityA,&cityB);
        G[cityA][cityB]=1;
        G[cityB][cityA]=1;
    }
    vector<int> ans;int ConcernedCities;
    ans.resize(k);
    for(int i=0;i<k;i++){
        scanf("%d",&ConcernedCities);
        fill(VertexVisited,VertexVisited+MAXV,false);
        VertexVisited[ConcernedCities]=true;//ConcernedCities[i]写成了i
        int cntConnectedComponent=0;
        for(int j=1;j<=n;j++){
            if(VertexVisited[j]==false){
                DFS(j,VertexVisited);
                cntConnectedComponent++;
            }
        }
        ans[i]=cntConnectedComponent-1;//这里应该再减去1
    }
    for(int i=0;i<k;i++)
        printf("%d\n",ans[i]);
    return 0;
}
//第一次code 失败
//没有体会到题目想考连通分量的计数
//问题？for循环第一次判断失败就会退出吗
~~~



# **1021** **Deepest Root** **(25** **分**)（图的遍历+连通分量计数）

A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called **the deepest root**.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤104) which is the number of nodes, and hence the nodes are numbered from 1 to *N*. Then *N*−1 lines follow, each describes an edge by given the two adjacent nodes' numbers.

### Output Specification:

For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print `Error: K components`where `K` is the number of connected components in the graph.

### Sample Input 1:

```in
5
1 2
1 3
1 4
2 5
```

### Sample Output 1:

```out
3
4
5
```

### Sample Input 2:

```in
5
1 3
1 4
2 5
3 4
```

### Sample Output 2:

```out
Error: 2 components
```

~~~C++
#include<iostream>
#include<set>
#include<vector>
#include<algorithm>
using namespace std;
const int MAXV = 10010;
vector<int> Adj[MAXV]; int MaxDepth = -1,n;
set<int> ans;
bool visited[MAXV] = { false };
void DFS(int u, int depth) {
	visited[u] = true;
	if (depth == MaxDepth) ans.insert(u);
	if (depth > MaxDepth) {
		MaxDepth = depth;
		ans.clear();
		ans.insert(u);
	}
	for (int i = 0; i < (int)Adj[u].size(); i++) {
		if (visited[Adj[u][i]] == false) {
			DFS(Adj[u][i], depth + 1);
		}
	}
}
int  DFSTravel() {
	int cntComponent = 0;
	for (int i = 1; i <= n; i++) {//这里该写maxv-1
		if (visited[i] == false) {
			DFS(i, 0);
			cntComponent++;
		}
	}
	return cntComponent;
}
int main() {
	int edgStart, edgeEnd;
	int i = 0;
	scanf("%d", &n);
	for (int i = 0; i < n - 1; i++) {
		scanf("%d%d", &edgStart, &edgeEnd);
		Adj[edgStart].push_back(edgeEnd);//无向图要强连通
		Adj[edgeEnd].push_back(edgStart);
	}
	int cnt = DFSTravel();
	if (cnt != 1) {
		printf("Error: %d components", cnt);
	}
	else {
		int newRoot = *ans.begin();
		//忘了刷新visited
		set<int> oldnode;
		for (auto it = ans.begin(); it != ans.end(); it++)
			oldnode.insert(*it);
		fill(visited, visited + MAXV, false);
		DFS(newRoot, 0);
		for(auto it=oldnode.begin();it!=oldnode.end();it++)
			ans.insert(*it);
		for (auto itt = ans.begin(); itt != ans.end(); itt++)
			printf("%d\n", *itt);
	}
	return 0;
}
//没有意识到自己算法是N2级别的
//图的问题不要通过遍历所有顶点实现
//心虚

//我的思路：
//deepestRoot=》求树的深度，用depth和一个maxdepth来判定=》每个都遍历一下就可以找出来；
/*
知道了先遍历一次再从最长叶可求=》写dfs=》需要根节点和depth的对应关系 传入depth
（实际上题目没有要求求根和深度的关系只要求根）=》
怎么实现两次都用一个dfs？（没考虑影响）=》
看到题干以为要判断连通！！就是要判断连通
*/
//仔细分析题干 看题目要求什么！
//题干说了有N个节点
//而且输的边数为N-1(构成树的最少边数)
//所以不会出现有连通分量为1且有环的情况（需要至少N条边）
//复习树和图的基本性质
//并且熟练掌握
//把里面所有的对应的英语词汇全部摘录下来
~~~

# **1003** **Emergency** **(25** **分**)（Dijkstra）

As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.

### Input Specification:

Each input file contains one test case. For each test case, the first line contains 4 positive integers: *N* (≤500) - the number of cities (and the cities are numbered from 0 to *N*−1), *M* - the number of roads, *C*1 and *C*2 - the cities that you are currently in and that you must save, respectively. The next line contains *N* integers, where the *i*-th integer is the number of rescue teams in the *i*-th city. Then *M* lines follow, each describes a road with three integers *c*1, *c*2 and *L*, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from *C*1 to *C*2.

### Output Specification:

For each test case, print in one line two numbers: the number of different shortest paths between *C*1 and *C*2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.

### Sample Input:

```in
5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1
```

### Sample Output:

```out
2 4
```

~~~C++
#include<iostream>
#include<algorithm>
#include<vector>
#define INF 0x3fffffff
using namespace std;
vector<vector<int>> G;
vector<int> dist,TeamsInCity,TeamsCnt,paths;
vector<bool> visited;int n;
void Dijkstra(int source){
    fill(dist.begin(),dist.end(),INF);
    fill(TeamsCnt.begin(),TeamsCnt.end(),0);
    dist[source]=0;paths[source]=1;
    TeamsCnt[source]=TeamsInCity[source];
    for(int i=0;i<n;i++){
        int u=-1,minWeight=INF;
        for(int v=0;v<n;v++){
            if(visited[v]==false&&dist[v]<minWeight){
                minWeight=dist[v];u=v;//segementfault
            }
        }
        if(u==-1) return;
        visited[u]=true;//差点忘了
        for(int v=0;v<n;v++){
            if(visited[v]==false&&G[u][v]!=INF){
                    //未被访问没写 访问未在集合内的邻结点
                if(dist[u]+G[u][v]<dist[v]){
                dist[v]=dist[u]+G[u][v];
                TeamsCnt[v]=TeamsCnt[u]+TeamsInCity[v];
                //这里写错了
                paths[v]=paths[u];
                //停顿时间长 这里是优化了TeamsCnt 为下一次的判断做准备
                //回去研究一下性质
                }else if(dist[u]+G[u][v]==dist[v]){
                    //写错了 这里应该也要保证是未访问过的
                    paths[v]+=paths[u];//这里不能用path 可能求只是局部最短
                    if(TeamsInCity[v]+TeamsCnt[u]>TeamsCnt[v])
                        TeamsCnt[v]=TeamsInCity[v]+TeamsCnt[u];
                }
            }
        }
    }
}
int main(){
    int m,c1,c2;
    scanf("%d%d%d%d",&n,&m,&c1,&c2);
    dist.resize(n);TeamsCnt.resize(n);
    paths.resize(n);TeamsInCity.resize(n);
    visited.resize(n);fill(visited.begin(),visited.end(),false);
    G.resize(n);for(int i=0;i<n;i++) G[i].resize(n);
    for(int i=0;i<n;i++){for(int j=0;j<n;j++) G[i][j]=INF;}
    for(int i=0;i<n;i++) scanf("%d",&TeamsInCity[i]);
    for(int i=0;i<m;i++){
        int a,b,weight;
        scanf("%d%d%d",&a,&b,&weight);
        G[a][b]=G[b][a]=weight;
    }
    Dijkstra(c1);
    printf("%d %d\n",paths[c2],TeamsCnt[c2]);
    return 0;
}
//这里是+= 因为paths的含义是 到这个点有几条
//最短路径可以走，下一个节点如果走法唯一将加上这个值
//因为这个值也是到这个点最短路径的走法。
//遇到了多个相等的情况 就会把多个相等的路径相加求这个路径的全部走法的目的
//我的思考是要做个乘法 但是那样的话需要一大堆不同的情况讨论
//因为对加在访问里面的dist的数组性质的不熟悉 导致思考的方向单一

~~~

# **1018** **Public Bike Management** **(30** **分**)(DFS+Dijkstra)

There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.

The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in **perfect** condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.

When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.

![img](https://images.ptausercontent.com/213)

The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex *S* is the current number of bikes stored at *S*. Given that the maximum capacity of each station is 10. To solve the problem at *S*3, we have 2 different shortest paths:

1. PBMC -> *S*1 -> *S*3. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from *S*1 and then take 5 bikes to *S*3, so that both stations will be in perfect conditions.
2. PBMC -> *S*2 -> *S*3. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.

### Input Specification:

Each input file contains one test case. For each case, the first line contains 4 numbers: *C**m**a**x* (≤100), always an even number, is the maximum capacity of each station; *N* (≤500), the total number of stations; *S**p*, the index of the problem station (the stations are numbered from 1 to *N*, and PBMC is represented by the vertex 0); and *M*, the number of roads. The second line contains *N* non-negative numbers *C**i* (*i*=1,⋯,*N*) where each *C**i* is the current number of bikes at *S**i*respectively. Then *M* lines follow, each contains 3 numbers: *S**i*, *S**j*, and *T**i**j* which describe the time *T**i**j* taken to move betwen stations *S**i* and *S**j*. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0−>*S*1−>⋯−>*S**p*. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of *S**p* is adjusted to perfect.

Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge's data guarantee that such a path is unique.

### Sample Input:

```in
10 3 3 5
6 7 0
0 1 1
0 2 1
0 3 3
1 3 1
2 3 1
```

### Sample Output:

```out
3 0->2->3 0
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
const int MAXV=510,INF=0x3fffffff;
int G[MAXV][MAXV],dist[MAXV],Cmax,N,Sp,M,minSend=INF,minBack=INF;
bool visit[MAXV]={false};
vector<int> pre[MAXV],tempPath,path,bikes;
void Dijkstra(int s){
    fill(dist,dist+MAXV,INF);
    dist[s]=0;
    for(int i=0;i<N;i++){
        int u=-1,minWeight=INF;
        for(int j=0;j<=N;j++){
            if(visit[j]==false&&dist[j]<minWeight){
                minWeight=dist[j];
                u=j;
            }
        }
        if(u==-1) return ;
        visit[u]=true;
        for(int v=0;v<=N;v++){
            if(G[u][v]!=INF&&visit[v]==false){
                if(dist[u]+G[u][v]<dist[v]){
                    dist[v]=dist[u]+G[u][v];
                    pre[v].clear();
                    pre[v].push_back(u);
                }else if(dist[u]+G[u][v]==dist[v])
                    pre[v].push_back(u);
            }
        }
    }
}
void DFS(int vertex){
    tempPath.push_back(vertex);
    if(vertex==0){//不考虑perfect状态
        int need = 0, back = 0,imperfect;
        for(int i = tempPath.size() - 2; i >= 0; i--) {
            int id = tempPath[i];
            imperfect=bikes[id]-Cmax;
            if(imperfect > 0) {
                back += imperfect;
            } else {
                if(back > (0 - imperfect)) {
                    back += imperfect;
                } else {
                    need += ((0 - imperfect) - back);
                    back = 0;
                }
            }
        }
        if(need < minSend) {
            minSend = need;
            minBack = back;
            path = tempPath;
        } else if(need == minSend && back < minBack) {
            minBack = back;
            path = tempPath;
        }
        tempPath.pop_back();
        return;
    }
    for(int i=0;i<(int)pre[vertex].size();i++)
        DFS(pre[vertex][i]);
    tempPath.pop_back();
}
int main(){
    scanf("%d%d%d%d",&Cmax,&N,&Sp,&M);
    Cmax=Cmax/2;bikes.resize(N+1);
    fill(G[0],G[0]+MAXV*MAXV,INF);
    bikes[0]=0;
    for(int i=1;i<=N;i++){
        scanf("%d",&bikes[i]);
    }
    for(int i=0;i<M;i++){
        int a,b,distantce;
        scanf("%d%d%d",&a,&b,&distantce);
        G[a][b]=G[b][a]=distantce;
    }
    Dijkstra(0);
    DFS(Sp);
    printf("%d ",minSend);
    for(int i=(int)path.size()-1;i>=0;i--){
        printf("%d%s",path[i],i==0?" ":"->");
    }
    printf("%d\n",minBack);
    return 0;
}
//题意理解错误：
//要先送车子到问题城市，回来的图中调整。

~~~

# **1087** **All Roads Lead to Rome** **(30** **分**)(Dijkstra+DFS)

Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.

### Input Specification:

Each input file contains one test case. For each case, the first line contains 2 positive integers *N* (2≤*N*≤200), the number of cities, and *K*, the total number of routes between pairs of cities; followed by the name of the starting city. The next *N*−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then *K* lines follow, each describes a route between two cities in the format `City1 City2 Cost`. Here the name of a city is a string of 3 capital English letters, and the destination is always `ROM` which represents Rome.

### Output Specification:

For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness -- it is guaranteed by the judge that such a solution exists and is unique.

Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format `City1->City2->...->ROM`.

### Sample Input:

```in
6 7 HZH
ROM 100
PKN 40
GDN 55
PRS 95
BLN 80
ROM GDN 1
BLN ROM 1
HZH PKN 1
PRS ROM 2
BLN HZH 2
PKN GDN 1
HZH PRS 1
```

### Sample Output:

```out
3 3 195 97
HZH->PRS->ROM
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
#include<map>
#include<string>
using namespace std;
const int MAXV=300,INF=0x3fffffff;string startCity;
int G[MAXV][MAXV],dist[MAXV],happiness[MAXV],shortest[MAXV],numCities,k,iCity=0;
bool visited[MAXV]={false};int maximumHappy=0,maximumAvrhappy=0;
vector<int> pre[MAXV],tmpPath,path;
map<string,int> st2int;
map<int,string> int2st;
int string2int(string name){
    int tmp=iCity;
    if(st2int.find(name)==st2int.end()){
        st2int[name]=iCity;
        int2st[iCity++]=name;
    }else{
        return st2int[name];
    }
    return tmp;
}
string int2string(int i){return int2st[i];}//保证输入合法
void Dijkstra(int st){
    fill(dist,dist+MAXV,INF);
    fill(shortest,shortest+MAXV,0);
    dist[st]=0;shortest[0]=1;
    for(int i=0;i<numCities;i++){
        int u=-1,minWeight=INF;
        for(int i=0;i<numCities;i++){
            if(visited[i]==false&&dist[i]<minWeight){
                u=i;minWeight=dist[i];
            }
        }
        if(u==-1) return ;
        visited[u]=true;
        for(int v=0;v<numCities;v++){
            if(G[u][v]!=INF&&visited[v]==false){
                if(G[u][v]+dist[u]<dist[v]){
                    dist[v]=G[u][v]+dist[u];
                    shortest[v]=shortest[u];
                    pre[v].clear();
                    pre[v].push_back(u);
                }else if(G[u][v]+dist[u]==dist[v]){
                    pre[v].push_back(u);
                    shortest[v]+=shortest[u];
                }
            }
        }
    }
}
void DFS(int id){
    tmpPath.push_back(id);
    if(id==0){
        int cntHappiness=0,Avr=0;
        for(int i=tmpPath.size()-1;i>=0;i--){
            int id=tmpPath[i];
            cntHappiness+=happiness[id];
        }
        int sizePath=tmpPath.size()-1;
        Avr=(int)(cntHappiness*1.0/(1.0*(sizePath)));
        if(cntHappiness>maximumHappy){
            maximumHappy=cntHappiness;
            path=tmpPath;maximumAvrhappy=Avr;
        }else if(cntHappiness==maximumHappy&&Avr>maximumAvrhappy){
            maximumAvrhappy=Avr;
            path=tmpPath;
        }
        tmpPath.pop_back();
        return;
    }
    for(int i=0;i<(int)pre[id].size();i++){
        DFS(pre[id][i]);
    }
    tmpPath.pop_back();
}
int main(){
    string name,name2;int happyValue,cost;
    fill(G[0],G[0]+MAXV*MAXV,INF);
    scanf("%d%d",&numCities,&k);cin>>startCity;
    string2int(startCity);
    st2int["ROM"]=numCities-1;
    int2st[numCities-1]="ROM";
    for(int i=0;i<numCities-1;i++){
        cin>>name>>happyValue;
        int id=string2int(name);
        happiness[id]=happyValue;
    }
    for(int i=0;i<k;i++){
        cin>>name>>name2>>cost;
        int IDa=string2int(name);
        int IDb=string2int(name2);
        G[IDa][IDb]=G[IDb][IDa]=cost;
    }
    Dijkstra(0);
    DFS(numCities-1);string cityName;
    printf("%d %d %d %d\n",shortest[numCities-1],\
           dist[numCities-1],maximumHappy,maximumAvrhappy);
    for(int i=path.size()-1;i>=0;i--){
        cityName=int2string(path[i]);
        printf("%s%s",cityName.c_str(),i==0?"\n":"->");
    }
    return 0;
}
//avr 计算方法出错
//对ROM的初值赋值错误
//pre没有加【】
//在DFS里面的pre没有用用pre[]
//IDa 和IDb没有反过来
//==写成了=

//柳神经验
//因为提供的数据比较齐全
//可以不用写string2int和int2string直接用map定义的映射就好了
//

~~~

# **1075** **PAT Judge** **(25** **分**)（排名 数据统计）

The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.

### Input Specification:

Each input file contains one test case. For each case, the first line contains 3 positive integers, *N* (≤104), the total number of users, *K* (≤5), the total number of problems, and *M* (≤105), the total number of submissions. It is then assumed that the user id's are 5-digit numbers from 00001 to *N*, and the problem id's are from 1 to *K*. The next line contains *K* positive integers `p[i]` (`i`=1, ..., *K*), where `p[i]` corresponds to the full mark of the i-th problem. Then *M* lines follow, each gives the information of a submission in the following format:

```
user_id problem_id partial_score_obtained
```

where `partial_score_obtained` is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, `p[problem_id]`]. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, you are supposed to output the ranklist in the following format:

```
rank user_id total_score s[1] ... s[K]
```

where `rank` is calculated according to the `total_score`, and all the users with the same `total_score` obtain the same `rank`; and `s[i]` is the partial score obtained for the `i`-th problem. If a user has never submitted a solution for a problem, then "-" must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.

The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id's. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.

### Sample Input:

```in
7 4 20
20 25 25 30
00002 2 12
00007 4 17
00005 1 19
00007 2 25
00005 1 20
00002 2 2
00005 1 15
00001 1 18
00004 3 25
00002 2 25
00005 3 22
00006 4 -1
00001 2 18
00002 1 20
00004 1 15
00002 4 18
00001 3 4
00001 4 2
00005 2 -1
00004 2 0
```

### Sample Output:

```out
1 00002 63 20 25 - 18
2 00005 42 20 0 22 -
2 00007 42 - 25 - 17
2 00001 42 18 18 4 2
5 00004 40 15 0 25 -
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct node {
	int rank, id, total = 0, passnum = 0;
	vector<int> score; bool isshown = false;
};
bool cmp(node a, node b) {
	if (a.total != b.total) return a.total > b.total;
	else if (a.passnum != b.passnum) return a.passnum > b.passnum;
	else return a.id < b.id;
}
int main() {
	int id, num, score, n, k, m;;
	vector<node> v; vector<int> full;
	scanf("%d%d%d", &n, &k, &m);
	full.resize(k + 1);
	v.resize(n + 1);
	for (int i = 1; i <= k; i++) {
		scanf("%d", &full[i]);
	}
	for (int i = 0; i <= n; i++) {
		v[i].score.resize(k + 1, -1);
		v[i].id = i;
	}
	for (int i = 0; i < m; i++) {
		scanf("%d%d%d", &id, &num, &score);
		v[id].id = id;
		if (score != -1) {
			v[id].isshown = true;
			if (v[id].score[num] < score) {
				v[id].score[num] = score;
			}
		}
		else if (v[id].score[num] == -1) v[id].score[num] = -2;
	}
	for (int i = 0; i <= n; i++) {

		for (int j = 1; j <= k; j++)
			if (v[i].score[j] != -1 && v[i].score[j] != -2) {
				v[i].total += v[i].score[j];
				if (v[i].score[j] == full[j])v[i].passnum++;
			}
	}
	sort(v.begin() + 1, v.end(), cmp);
	v[1].rank = 1;
	for (int i = 2; i <= n; i++) {//wrong
		if (v[i].total == v[i - 1].total)
			v[i].rank = v[i - 1].rank;
		else v[i].rank = i;
	}

	for (int i = 1; i <= n; i++) {//wrong
		if (v[i].isshown == true) {
			printf("%d %05d %d", v[i].rank, v[i].id, v[i].total);
			for (int j = 1; j <= 4; j++) {
				if (v[i].score[j] != -1 && v[i].score[j] != -2)
					printf(" %d", v[i].score[j]);
				else if (v[i].score[j] == -1)
					printf(" -");
				else
					printf(" 0");
			}
			printf("\n");
		}
	}

	return 0;
}
//segmentFault:
//在cmp中使用了初始化的量 在定义了maxn要尤其注意
//答案错误：
//输出格式不正确：
//目前已经犯下的有
/*
1、输出大小写不注意
2、 把变量的位置写成了测试用例的常量
3、对英文的输出格式控制不敏感
*/
/*
思路一开始不清楚：
没有构思好数据结构：走一步看一步（无目的）
其中结构体中id困扰了自己，最好是定义，如果有需要读取id的地方（例如比较）定义了之
后可以很方便的进行读写。
不知道怎么初始化优雅就用 for循环 不用想太多肯定对



审题忽视一些重要条件：
1、题目中给定了user的范围是从1-N所以我们大可不必定义一个maxn来开空间
2、这题给出了FullScore却到了测试的时候才知道怎么用，读题不认真忽略了一个perfectly。
3、读题目时候没有看到隐藏（也不算什么刻意隐藏）的条件：要求在在多次submit中取最高值
4、读题目的时候不知道将提交了答案却没有通过编译器的和没有提交答案的区别开来

newSkillGet：
resize(1000,-1);
vector不仅在声明的时候可以这么做，而且在resize的时候也可以这样初始化，vector.

Reflect:
读取和统计分开做
逻辑比较清楚 类似的题目也做过了 可以找找看反思一下
*/
~~~

# **1077** **Kuchiguse** **(20** **分**)(逻辑 题意理解)

The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker's personality. Such a preference is called "Kuchiguse" and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle "nyan~" is often used as a stereotype for characters with a cat-like personality:

- Itai nyan~ (It hurts, nyan~)
- Ninjin wa iyada nyan~ (I hate carrots, nyan~)

Now given a few lines spoken by the same character, can you find her Kuchiguse?

### Input Specification:

Each input file contains one test case. For each case, the first line is an integer *N* (2≤*N*≤100). Following are *N* file lines of 0~256 (inclusive) characters in length, each representing a character's spoken line. The spoken lines are case sensitive.

### Output Specification:

For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all *N* lines. If there is no such suffix, write `nai`.

### Sample Input 1:

```in
3
Itai nyan~
Ninjin wa iyadanyan~
uhhh nyan~
```

### Sample Output 1:

```out
nyan~
```

### Sample Input 2:

```in
3
Itai!
Ninjinnwaiyada T_T
T_T
```

### Sample Output 2:

```out
nai
```

~~~C++
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
int main(){
    int n;
    string tmpGet,suffix;
    scanf("%d\n",&n);
    for(int i=0;i<n;i++){
        getline(cin,tmpGet);
        reverse(tmpGet.begin(),tmpGet.end());
        if(i==0){
            suffix=tmpGet;
        }else{
            int lenSuffix=suffix.length();
            int lenTmpGet=tmpGet.length();
            int minlen=min(lenSuffix,lenTmpGet);
            for(int i=0;i<minlen;i++){
                if(suffix[i]!=tmpGet[i]){
                    suffix=suffix.substr(0,i);
                    break;
                }
            }
        }
    }
    reverse(suffix.begin(),suffix.end());
    if(suffix.length()) cout<<suffix<<endl;
    else cout<<"nai"<<endl;
    return 0;
}
//等效转换
//找比较后缀转换成比较前缀 找正确/错误 找最短的路径....
//
//题意理解
//反转比较和有效长度取字符串
//substr的用法用i判断不相等的地方直接substr就可以达到效果

//柳神新方法：
/*
不断比较字符串取字符串相等的地方
通过不相等的点 用substr反复截断
最后 lenth为0即为不存在
*/
~~~



# **1078** **Hashing** **(25** **分**)（平方探测法+素数）

The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be *H*(*k**e**y*)=*k**e**y*%*T**S**i**z**e* where *T**S**i**z**e* is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.

Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.

### Input Specification:

Each input file contains one test case. For each case, the first line contains two positive numbers: *M**S**i**z**e* (≤104) and *N* (≤*M**S**i**z**e*) which are the user-defined table size and the number of input numbers, respectively. Then *N* distinct positive integers are given in the next line. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print "-" instead.

### Sample Input:

```in
4 4
10 6 4 15
```

### Sample Output:

```out
0 1 4 -
```

~~~C++
#include<iostream>
#include<vector>
using namespace std;
int Msize,n;const int primeNumEdge=10010;
vector<int> hashTable;
void insert(int key){
    int index=key,step=0;
    for(;step<Msize;step++){
        index=(key+step*step)%Msize;
        if(hashTable[index]==0){
            hashTable[index]=1;
            cout<<index;return;
        }
    }
    cout<<"-";
}
int main(){
    vector<bool> isPrime(primeNumEdge,true);//只能赋值0
    for(int i=2;i<primeNumEdge;i++){
        for(int j=2;j*i<primeNumEdge;j++)
            isPrime[i*j]=false;//实现方式 有瑕疵
    }
    isPrime[1]=false;isPrime[0]=false;
    scanf("%d%d",&Msize,&n);
    while(!isPrime[Msize]) Msize++;
    hashTable.resize(Msize,0);
    int key;
    for(int i=0;i<n;i++){
        scanf("%d",&key);
        if(i!=0) cout<<" ";
        insert(key);
    }
    return 0;
}
//各个类模板对find的函数的返回值和找不到的情况的处理
//素数的实现不熟练
~~~



# **1080** **Graduate Admission** **(30** **分**)（统计）

It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.

Each applicant will have to provide two grades: the national entrance exam grade *G**E*, and the interview grade *G**I*. The final grade of an applicant is (*G**E*+*G**I*)/2. The admission rules are:

- The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.
- If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade *G**E*. If still tied, their ranks must be the same.
- Each applicant may have *K* choices and the admission will be done according to his/her choices: if according to the rank list, it is one's turn to be admitted; and if the quota of one's most preferred shcool is not exceeded, then one will be admitted to this school, or one's other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.
- If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, **even if its quota will be exceeded**.

### Input Specification:

Each input file contains one test case.

Each case starts with a line containing three positive integers: *N* (≤40,000), the total number of applicants; *M* (≤100), the total number of graduate schools; and *K* (≤5), the number of choices an applicant may have.

In the next line, separated by a space, there are *M* positive integers. The *i*-th integer is the quota of the *i*-th graduate school respectively.

Then *N* lines follow, each contains 2+*K* integers separated by a space. The first 2 integers are the applicant's *G**E* and *G**I*, respectively. The next *K* integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to *M*−1, and the applicants are numbered from 0 to *N*−1.

### Output Specification:

For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants' numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.

### Sample Input:

```in
11 6 3
2 1 2 2 2 3
100 100 0 1 2
60 60 2 3 5
100 90 0 3 4
90 100 1 2 0
90 90 5 1 3
80 90 1 0 2
80 80 0 1 2
80 80 0 1 2
80 70 1 3 2
70 80 1 2 3
100 100 0 2 4
```

### Sample Output:

```out
0 10
3
5 6 7
2 8

1 4
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct appliant {
	int id, Ge, Gi, rank;
	int score;
	vector<int> choice;
};
vector<appliant> appList;
struct school {
	int quota, lastRank;
	vector<int> enrollList;
};
vector<school> university;
int n, m, k;
bool cmp(appliant &a, appliant &b) {
	if (a.score != b.score) return a.score > b.score;
	else return a.Ge > b.Ge;
}
int main() {
	scanf("%d%d%d", &n, &m, &k);
	appList.resize(n);
	university.resize(m);
	for (int i = 0; i < n; i++) {
		appList[i].id = i; appList[i].choice.resize(k);
	}
	for (int i = 0; i < m; i++) {
		scanf("%d", &university[i].quota);
	}
	for (int i = 0; i < n; i++) {
		scanf("%d%d", &appList[i].Ge, &appList[i].Gi);
		appList[i].score = appList[i].Ge + appList[i].Gi;
		for (int j = 0; j < k; j++)
			scanf("%d", &appList[i].choice[j]);
	}
	sort(appList.begin(), appList.end(), cmp);
	for (int i = 0; i < n; i++) {
		appList[i].rank = i;
		if (i != 0) {
			int preScore = appList[i - 1].score;
			int nextScore = appList[i].score;
			if (preScore == nextScore && appList[i].Ge == appList[i - 1].Ge)
				appList[i].rank = appList[i - 1].rank;
		}
	}
	for (int i = 0; i < n; i++) {//有磕绊
		for (int j = 0; j < k; j++) {
			int target = appList[i].choice[j];
			int stu = appList[i].id;
			int size = university[target].enrollList.size();
			if (university[target].quota > 0) {
				university[target].enrollList.push_back(stu);
				university[target].lastRank = appList[i].rank;//i不代表真实的rank
				university[target].quota--;
				break;
			}
			else if (size != 0 && appList[i].rank == university[target].lastRank) {
				university[target].enrollList.push_back(stu);
				break;
			}//logical failure
		}
	}
	for (int i = 0; i < m; i++) {
		sort(university[i].enrollList.begin(), university[i].enrollList.end());
		for (int j = 0; j < (int)university[i].enrollList.size(); j++) {
			if (j != 0) printf(" ");
			printf("%d", university[i].enrollList[j]);
		}
		printf("\n");
	}
	return 0;
}
//不够快
//不用除以二
//？又要排错了...............
//fatal error
/****把i当成rank使用了****/
/*
当与柳神的思路相差过大的时候怎么排错
字母级观察：确定怀疑对象 这个量有没有赋值正确 是不是这个量？
怀疑逻辑错误：看别人的思路改写自己的代码
*/

/*等效是种好思想
用float麻烦时就考虑一下有没有等效的做法 不用求平均
*/

/*
不够快：
将任务模块化 首先 想好大体思路 决定数据结构
到具体某个模块的编写时 先想好思路再动手
*/

~~~

# **1081** **Rational Sum** **(20** **分**)（数字处理）

Given *N* rational numbers in the form `numerator/denominator`, you are supposed to calculate their sum.

### Input Specification:

Each input file contains one test case. Each case starts with a positive integer *N* (≤100), followed in the next line *N* rational numbers `a1/b1 a2/b2 ...` where all the numerators and denominators are in the range of **long int**. If there is a negative number, then the sign must appear in front of the numerator.

### Output Specification:

For each test case, output the sum in the simplest form `integer numerator/denominator` where `integer` is the integer part of the sum, `numerator` < `denominator`, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.

### Sample Input 1:

```in
5
2/5 4/15 1/30 -2/60 8/3
```

### Sample Output 1:

```out
3 1/3
```

### Sample Input 2:

```in
2
4/3 2/3
```

### Sample Output 2:

```out
2
```

### Sample Input 3:

```in
3
1/3 -1/6 1/8
```

### Sample Output 3:

```out
7/24
```

作者: CHEN, Yue

单位: 浙江大学

时间限制: 400 ms

内存限制: 64 MB

~~~C++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
#define elementType long int
elementType gcd(elementType a,elementType b){
    return a%b==0?b:gcd(b,a%b);
}
elementType maxAmplify(elementType a,elementType b){
    return a/gcd(a,b)*b;//负数有效
}
int main(){
    int n;vector<elementType> num,den;
    scanf("%d",&n);
    num.resize(n);den.resize(n);
    getchar();
    for(int i=0;i<n;i++) {
        scanf("%lld/%lld",&num[i],&den[i]);
        int gc=gcd(num[i],den[i]);
        num[i]/=gc;den[i]/=gc;
    }
    int sumNum=num[0],sumDen=den[0];
    for(int i=1;i<n;i++){
        int maxAm=maxAmplify(sumDen,den[i]);
        int preAm=maxAm/sumDen,nextAm=maxAm/den[i];
        sumNum=sumNum*preAm+num[i]*nextAm;
        sumDen=maxAm;
        int gc=gcd(sumNum,sumDen);
        sumNum/=gc;sumDen/=gc;
    }
    int sumOfnum=sumNum,denMaxAm=sumDen;
    elementType intergePart=sumOfnum/denMaxAm;
    if(intergePart==0&&sumOfnum!=0)
        printf("%lld/%lld",sumOfnum,denMaxAm);
    else if(intergePart==0&&sumOfnum==0)
        printf("%d",0);
    else if(denMaxAm==1)
        printf("%lld",intergePart);
    else
        printf("%lld %lld/%lld",intergePart,sumOfnum%denMaxAm,denMaxAm);
    return 0;
}
//忽视warning lld codeblocks的lld很辣鸡
//小知识：
/*
分数相加的时候 两两相加的时候所用的位数最小
分数要考虑假分数 0 等特殊情况
输出考虑 0 无穷 纯整数 假分数 真分数
多组数相加的时候两两相加再化简
gcd对负数也有用
*/
//没有考虑最长的长度
//特殊情况 没有考虑为0 没有想到最防止过长的完美处理
/*
审题的时候考虑这些数字类的特殊情况
*/


~~~

# **1082** **Read Number in Chinese** **(25** **分**)(问题抽象与逻辑方案的实现)

Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output `Fu` first if it is negative. For example, -123456789 is read as `Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu`. Note: zero (`ling`) must be handled correctly according to the Chinese tradition. For example, 100800 is `yi Shi Wan ling ba Bai`.

### Input Specification:

Each input file contains one test case, which gives an integer with no more than 9 digits.

### Output Specification:

For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.

### Sample Input 1:

```in
-123456789
```

### Sample Output 1:

```out
Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu
```

### Sample Input 2:

```in
100800
```

### Sample Output 2:

```out
yi Shi Wan ling ba Bai
```


  ~~~C++
#include<iostream>
#include<cmath>
using namespace std;
string num[10] = { "ling","yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu" };
string c[4] = { "Ge","Shi", "Bai","Qian"};
string unit[2]={ "Yi", "Wan"};
int J[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000 };
int main(){
    int n;
    scanf("%d",&n);
    if(n==0) {
        cout<<"ling"<<endl;
        return 0;
    }
    if(n<0)cout<<"Fu ";
    n=abs(n);
    int printspace=0;
    bool zero=false;
    int curPos;
    for(int i=0;i<3;i++){
        for(int j=3;j>=0;j--){
            curPos=8-i*4+j;
            if(curPos>=9) continue;
            int cur=(n/J[curPos])%10;
            if(cur!=0){
                if(zero){
                    cout<<" "<<num[0];
                    zero=false;
                }
                printspace++==0?cout<<num[cur]:cout<<" "<<num[cur];
                if(curPos%4!=0) cout<<" "<<c[curPos%4];
            }else if(!zero&&curPos>=1&&j&&n/J[curPos-1]>=10) zero=true;//obsecure
        }
        if(i!=2&&n/J[curPos]>0) printspace++==0?cout<<unit[i]:cout<<" "<<unit[i];
    }
    return 0;
}

//我的思路：
/*
先转换str//没想到其他的方案不一定非要str 取模和除法的操作焊方便
分成每四个组成一个小组 组内处理数字输出 组外再处理单位输出
碰到0先输出ling，等到第一个不为0的数，在输出
if(str[i]==0) cout<<"ling"<<endl;
if(str[i]==0) continue;

问题：难以分组
难以对头部难以处理 不知道怎么处理头部的不定长问题 曾想过补0但是嫌麻烦..
//利用下标指针逐个指过去 如果怎样怎样就continue
//头部 让他除以一个数字的整数倍如果小于他就会变成零
*/
/*柳神的思路：
将通过除法和取模操作 数字分成三个part 
在大循环处理 亿万千
在小循环处理 x千x百x十 其中每两个组成一组
通过0判断判断要不要输出数字
用curPos来指示位置和取得当前位置
printcnt实现对空格的控制

注意到了输出0时候的性质 只有最高位的前两位有着》=10的数字往后的最高前两位都是0
从而达成了只在一组0中输出一次的效果
*/

//字符串处理的小技巧：
/*
将一个变量作为 下标的指针进行操作。

字符串临界状态的预防：
数据流流动的可能方向：开头 中间 结尾 0 负值

问题的解决：
抓出关键的信息 
chinese tradition：
分解约束条件：
1、把输出每四位输出成 x千x百x十x
2、中间有相隔大于一个0且后面至少有个不为0的数时输出0 并忽略中间的千 百 十

条件足够简单的等效：
转换形式：
可以看做数字量大小的比较
可以看做字符串的比较

选定数据结构：
字符，数字

注意代码的边界和问题的边界
*/
  ~~~

# **1084** **Broken Keyboard** **(20** **分**)(送分 思路转换)

On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.

Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.

### Input Specification:

Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or `_` (representing the space). It is guaranteed that both strings are non-empty.

### Output Specification:

For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.

### Sample Input:

```in
7_This_is_a_test
_hs_s_a_es
```

### Sample Output:

```out
7TI
```

~~~c++
#include<iostream>
#include<cctype>
#include<string>
using namespace std;
int main(){
    string a,b,ans;
    cin>>a>>b;
    for(int i=0;i<(int)a.size();i++)
        if(b.find(a[i])==string::npos&&ans.find(toupper(a[i]))==string::npos)
        ans+=toupper(a[i]);
    cout<<ans;
    return 0;
}
//不一定要unordermap 不插入也可以做到啊 unordermap谨慎使用
// 找字符差异find是一把手
//结果不要求格式可以留到最后输出

~~~

# 1085 Perfect Sequence (25 分)(送分 但是逻辑错误了 题目看错了)



Given a sequence of positive integers and another positive integer *p*. The sequence is said to be a **perfect sequence** if *M*≤*m*×*p* where *M* and *m* are the maximum and minimum numbers in the sequence, respectively.

Now given a sequence and a parameter *p*, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.

### Input Specification:

Each input file contains one test case. For each case, the first line contains two positive integers *N* and *p*, where *N* (≤105) is the number of integers in the sequence, and *p* (≤109) is the parameter. In the second line there are *N* positive integers, each is no greater than 109.

### Output Specification:

For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.

### Sample Input:

```in
10 8
2 3 20 4 5 1 6 7 8 9
```

### Sample Output:

```out
8
```



~~~C++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
#define Type long long
vector<Type> v;
int main() {
	int n;
	Type p;
	scanf("%d%lld", &n, &p);
	v.resize(n);
	for (int i = 0; i < n; i++) {
		scanf("%lld", &v[i]);
	}
	sort(v.begin(), v.end());
	int length = 0;
	for (int i = 0; i < n; i++) {
		if (n - i - 1 < length) break;
		auto pos = upper_bound(v.begin(), v.end(), p*v[i]);
		length = max((int)(pos - v.begin() - i), length);
	}
	cout << length << endl;
	return 0;
}
//if (pos != v.end())逻辑大失败 找不到说明都可以
//max里面要强制转换才能用
//题意理解错误
~~~

