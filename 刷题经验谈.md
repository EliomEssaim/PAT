# a1043 Is It a Binary Search Tree (25 分)

A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

If we swap the left and right subtrees of every node, then the resulting tree is called the **Mirror Image** of a BST.

Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤1000). Then *N* integer keys are given in the next line. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first print in a line `YES` if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or `NO` if not. Then if the answer is `YES`, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
8 6 5 7 10 8 11
```

### Sample Output 1:

```out
YES
5 7 6 8 11 10 8
```

### Sample Input 2:

```in
7
8 10 11 8 6 7 5
```

### Sample Output 2:

```out
YES
11 8 10 7 5 6 8
```

### Sample Input 3:

```in
7
8 6 8 5 10 9 11
```

### Sample Output 3:

```out
NO
```

~~~C++
#include<iostream>
#include<vector>
#include <algorithm>
using namespace std;
vector<int> pre,post;bool isMirror=false;
void PostOrder(int start,int eend){
    if(start>eend) return ;
    int root=start,leftEnd=eend,RightStart=start+1;
    if(!isMirror){
        while(leftEnd>=root+1&&pre[root]<=pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]>pre[RightStart]) RightStart++;
    }
    else{//修改耗时
        while(leftEnd>=root+1&&pre[root]>pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]<=pre[RightStart]) RightStart++;
    }
    if(RightStart-leftEnd!=1) return;//耗时部分临界点的处理
    PostOrder(root+1,leftEnd);
    PostOrder(RightStart,eend);
    post.push_back(pre[root]);
}
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    for(int i=0;i<n;i++)
        scanf("%d",&pre[i]);
    PostOrder(0,n-1);
    if((int)post.size()<n){
        isMirror=true;
        post.clear();//忘了清理；
        PostOrder(0,n-1);
    }
    if((int)post.size()<n) printf("NO\n");
    else {
        printf("YES\n");
        for(int i=0;i<n;i++)
            printf("%d%c",post[i],i==n-1?'\n':' ');
    }
    return 0;
}
//要给定搜索序列的开始和结束为位置，给出正常的终止条件给出异常的判断
//柳神的思路：给出了一个重要的二叉树思想，递归的处理序列，在什么位置处理就是什么位置的遍历十分简洁高效

~~~



# **1090** **Highest Price in Supply Chain** **(25** **分**)

A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.

Starting from one root supplier, everyone on the chain buys products from one's supplier in a price *P* and sell or distribute them in a price that is *r*% higher than *P*. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.

Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers.

### Input Specification:

Each input file contains one test case. For each case, The first line contains three positive numbers: *N* (≤105), the total number of the members in the supply chain (and hence they are numbered from 0 to *N*−1); *P*, the price given by the root supplier; and *r*, the percentage rate of price increment for each distributor or retailer. Then the next line contains *N* numbers, each number *S**i* is the index of the supplier for the *i*-th member. *S**r**o**o**t* for the root supplier is defined to be −1. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed 1010.

### Sample Input:

```in
9 1.80 1.00
1 5 4 4 -1 4 5 3 6
```

### Sample Output:

```out
1.85 2
```

~~~c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
int maxDepth=0,num=1;
vector<int> tree[100010];
void dfs(int index,int d){
    if(tree[index].empty()){
        if(d>maxDepth){
            maxDepth=d;
            num=1;
        }else if(d==maxDepth){
            num++;
        }
    }
    for(int i=0;i<(int)tree[index].size();i++){
        dfs(tree[index][i],d+1);
    }
    return;
}
double p,r,maxPrice;
int main(){
    int n;
    scanf("%d%lf%lf",&n,&p,&r);
    r/=100;int root=0,tmp;
    for(int i=0;i<n;i++){
        scanf("%d",&tmp);//不熟悉下标和值的关系
        if(tmp==-1) root=i;
        else tree[tmp].push_back(i);
    }
    dfs(root,0);
    maxPrice=p*pow(1+r,maxDepth);
    printf("%.2f %d",maxPrice,num);

    return 0;
}
~~~



# 1119 Pre- and Post-order Traversals (30 分)



Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.

Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first printf in a line `Yes` if the tree is unique, or `No` if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
```

### Sample Output 1:

```out
Yes
2 1 6 4 7 3 5
```

### Sample Input 2:

```in
4
1 2 3 4
2 4 3 1
```

### Sample Output 2:

```out
No
2 1 3 4
```



```C++
#include<iostream>
#include<vector>
using namespace std;
vector<int> pre,post,in;
bool isUnique=true;int inPos=0;
void inOrder(int root,int start,int eend){
    if(start>eend) return;
    int leftEnd=eend;
    while(pre[root+1]!=post[leftEnd]&&leftEnd!=-1) leftEnd--;
    int leftEndSize=leftEnd-start+1;
    if((start-eend+1)%2==0) isUnique=false;
    inOrder(root+1,start,leftEnd);
    in[inPos++]=pre[root];
    if(leftEnd!=-1) inOrder(root+1+leftEndSize,leftEnd+1,eend-1);
    else inOrder(root+1+leftEndSize,start+1,eend-1);//这里写错了逻辑不清楚，
}
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    post.resize(n);
    in.resize(n);
    for(int i=0;i<n;i++) scanf("%d",&pre[i]);
    for(int i=0;i<n;i++) scanf("%d",&post[i]);
    inOrder(0,0,n-1);
    if(isUnique) printf("Yes\n");
    else printf("No\n");
    for(int i=0;i<n;i++)
        printf("%d%c",in[i],i==n-1?'\n':' ');
    return 0;
}
/*******************************************/
/*
逻辑不清楚，首先start和end谁是谁的没搞清楚
应该一个序列提供跟节点一个序列利用自己去锁定下一个根节点；同时更新一下自己的查找范围。
此外本次不同于普通的中序遍历，会出现特殊结果leftEnd=-1；的情况，没有充分考虑=-1的情况下
对后续的程序的影响（例如右子树的后序的锁定范围会出现变化）

逻辑想的慢：
正常：第一次做前后序转中序；难免会对下一次取值生疏
但是下次可以考量一下什么函数要做什么，这个变量的意义
如root start eend的意义搞清楚后就不会有模糊的地方了。

模板改进题：
如果出现了新的值要考虑对原有模板的代码的影响

学习方式：
搞清楚模板函数各个参量的意义，改变他会有造成什么影响

调试窗口的调用：
调试-》调试窗口-》监视
调试-》调试窗口-》调用栈
*/
/********************************************/


```

# 1114 Family Property (25 分)



This time, you are supposed to help us collect the data for family-owned property. Given each person's family members, and the estate（房产）info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤1000). Then *N* lines follow, each gives the infomation of a person who owns estate in the format:

```
ID` `Father` `Mother` *k* *C**h**i**l**d*1⋯*C**h**i**l**d**k* *M**e**s**t**a**t**e* `Area
```

where `ID` is a unique 4-digit identification number for each person; `Father` and `Mother` are the `ID`'s of this person's parents (if a parent has passed away, `-1` will be given instead); *k* (0≤*k*≤5) is the number of children of this person; *C**h**i**l**d**i*'s are the `ID`'s of his/her children; *M**e**s**t**a**t**e* is the total number of sets of the real estate under his/her name; and `Area` is the total area of his/her estate.

### Output Specification:

For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format:

`ID` `M` *A**V**G**s**e**t**s* *A**V**G**a**r**e**a*

where `ID` is the smallest ID in the family; `M` is the total number of family members; *A**V**G**s**e**t**s* is the average number of sets of their real estate; and *A**V**G**a**r**e**a* is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID's if there is a tie.

### Sample Input:

```in
10
6666 5551 5552 1 7777 1 100
1234 5678 9012 1 0002 2 300
8888 -1 -1 0 1 1000
2468 0001 0004 1 2222 1 500
7777 6666 -1 0 2 300
3721 -1 -1 1 2333 2 150
9012 -1 -1 3 1236 1235 1234 1 100
1235 5678 9012 0 1 50
2222 1236 2468 2 6661 6662 1 300
2333 -1 3721 3 6661 6662 6663 1 100
```

### Sample Output:

```out
3
8888 1 1.000 1000.000
0001 15 0.600 100.000
5551 4 0.750 100.000
```

~~~C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct DATA {
	int id, fid, mid, estate, area, members = 0;
};
struct node {
	int id, TotalMembers;
	double avrEstate, avrArea;
	bool isExist = false;
}ans[10010];
int father[10010];
bool visit[10010] = { false };
int findFather(int x) {
	int fa = x;
	while (fa != father[fa]) fa = father[fa];
	int upfa = x;
	while (upfa != father[upfa]) {
		upfa = father[upfa];
		father[x] = fa;
		x = upfa;
	}
	return fa;
}
void Union(int a, int b) {
	int fa = findFather(a);
	int fb = findFather(b);
	if (fa > fb) father[fa] = fb;//敲黑板！！
	if (fa < fb) father[fb] = fa;
}
bool cmp(node a, node b) {
	return a.avrArea != b.avrArea ? a.avrArea > b.avrArea:a.id < b.id;
}
int main() {
	int n, k, childID;
	vector<DATA> Data;
	scanf("%d", &n);
	for (int i = 0; i < 10010; i++)
		father[i] = i;
	Data.resize(n);
	for (int i = 0; i < n; i++) {
		scanf("%d%d%d%d", &Data[i].id, &Data[i].fid, &Data[i].mid, &k);
		if (visit[Data[i].id] == false)
		{
			Data[i].members++; visit[Data[i].id] = true;
		};
		//柳神的data不是用id做索引而是以下标为索引！！体会一下
		if (Data[i].fid != -1) {
			Union(Data[i].id, Data[i].fid);
			if (visit[Data[i].fid] == false)
			{
				Data[i].members++; visit[Data[i].fid] = true;
			};
			//会重复计算！！没有想到
		}
		if (Data[i].mid != -1) {
			Union(Data[i].id, Data[i].mid);
			if (visit[Data[i].mid] == false)
			{
				Data[i].members++; visit[Data[i].mid] = true;
			};
		}
		for (int j = 0; j < k; j++) {
			scanf("%d", &childID);
			Union(Data[i].id, childID);
			if (visit[childID] == false)
			{
				Data[i].members++; visit[childID] = true;
			};
		}
		scanf("%d%d", &Data[i].estate, &Data[i].area);
	}
	int cnt = 0;
	for (int i = 0; i < n; i++) {
		ans[findFather(Data[i].id)].id = findFather(Data[i].id);
		ans[findFather(Data[i].id)].TotalMembers += Data[i].members;
		ans[findFather(Data[i].id)].avrArea += Data[i].area;//+=没写
		ans[findFather(Data[i].id)].avrEstate += Data[i].estate;
		ans[findFather(Data[i].id)].isExist = true;
	}
	for (int i = 0; i < 10010; i++) {
		if (ans[i].isExist == true) {
			cnt++;
			ans[i].avrArea = (double)ans[i].avrArea / (double)ans[i].TotalMembers;
			ans[i].avrEstate = (double)ans[i].avrEstate / (double)ans[i].TotalMembers;
		}
	}
	sort(ans, ans + 10010, cmp);
	printf("%d\n", cnt);
	for (int i = 0; i < cnt; i++)
		printf("%04d %d %.3lf %.3lf\n", ans[i].id, ans[i].TotalMembers, \
			ans[i].avrEstate, ans[i].avrArea);
	return 0;
}

//我所遇到的问题：
/*
1.如何实现集合的表示？以及如何让有交集的集合合并？
还有如何让集合和其他信息房产挂钩？
使用并查集：难以实现交集则合并且根唯一
思路是先合并一组数据 然后判断这个家族是否有成员是其他
（判断有没有父亲再合并这个方法真的蠢爆了）
（因为father仅仅是第一个不具有什么特征，所以担心father会改来改去 同一集合）
集合的一部分（写个flag） 如果是则和那个集合合并

*/
/*
用数组分割功能
*/

~~~

