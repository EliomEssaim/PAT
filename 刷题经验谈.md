# a1043 Is It a Binary Search Tree (25 分)

A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:

- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
- Both the left and right subtrees must also be binary search trees.

If we swap the left and right subtrees of every node, then the resulting tree is called the **Mirror Image** of a BST.

Now given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.

### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤1000). Then *N* integer keys are given in the next line. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first print in a line `YES` if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or `NO` if not. Then if the answer is `YES`, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
8 6 5 7 10 8 11
```

### Sample Output 1:

```out
YES
5 7 6 8 11 10 8
```

### Sample Input 2:

```in
7
8 10 11 8 6 7 5
```

### Sample Output 2:

```out
YES
11 8 10 7 5 6 8
```

### Sample Input 3:

```in
7
8 6 8 5 10 9 11
```

### Sample Output 3:

```out
NO
```

~~~C++
#include<iostream>
#include<vector>
#include <algorithm>
using namespace std;
vector<int> pre,post;bool isMirror=false;
void PostOrder(int start,int eend){
    if(start>eend) return ;
    int root=start,leftEnd=eend,RightStart=start+1;
    if(!isMirror){
        while(leftEnd>=root+1&&pre[root]<=pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]>pre[RightStart]) RightStart++;
    }
    else{//修改耗时
        while(leftEnd>=root+1&&pre[root]>pre[leftEnd])leftEnd--;//等号处理左子树空的情况
        while(RightStart<=eend&&pre[root]<=pre[RightStart]) RightStart++;
    }
    if(RightStart-leftEnd!=1) return;//耗时部分临界点的处理
    PostOrder(root+1,leftEnd);
    PostOrder(RightStart,eend);
    post.push_back(pre[root]);
}
using namespace std;
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    for(int i=0;i<n;i++)
        scanf("%d",&pre[i]);
    PostOrder(0,n-1);
    if((int)post.size()<n){
        isMirror=true;
        post.clear();//忘了清理；
        PostOrder(0,n-1);
    }
    if((int)post.size()<n) printf("NO\n");
    else {
        printf("YES\n");
        for(int i=0;i<n;i++)
            printf("%d%c",post[i],i==n-1?'\n':' ');
    }
    return 0;
}
//要给定搜索序列的开始和结束为位置，给出正常的终止条件给出异常的判断
//柳神的思路：给出了一个重要的二叉树思想，递归的处理序列，在什么位置处理就是什么位置的遍历十分简洁高效

~~~



# **1090** **Highest Price in Supply Chain** **(25** **分**)

A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.

Starting from one root supplier, everyone on the chain buys products from one's supplier in a price *P* and sell or distribute them in a price that is *r*% higher than *P*. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.

Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers.

### Input Specification:

Each input file contains one test case. For each case, The first line contains three positive numbers: *N* (≤105), the total number of the members in the supply chain (and hence they are numbered from 0 to *N*−1); *P*, the price given by the root supplier; and *r*, the percentage rate of price increment for each distributor or retailer. Then the next line contains *N* numbers, each number *S**i* is the index of the supplier for the *i*-th member. *S**r**o**o**t* for the root supplier is defined to be −1. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed 1010.

### Sample Input:

```in
9 1.80 1.00
1 5 4 4 -1 4 5 3 6
```

### Sample Output:

```out
1.85 2
```

~~~c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
int maxDepth=0,num=1;
vector<int> tree[100010];
void dfs(int index,int d){
    if(tree[index].empty()){
        if(d>maxDepth){
            maxDepth=d;
            num=1;
        }else if(d==maxDepth){
            num++;
        }
    }
    for(int i=0;i<(int)tree[index].size();i++){
        dfs(tree[index][i],d+1);
    }
    return;
}
double p,r,maxPrice;
int main(){
    int n;
    scanf("%d%lf%lf",&n,&p,&r);
    r/=100;int root=0,tmp;
    for(int i=0;i<n;i++){
        scanf("%d",&tmp);//不熟悉下标和值的关系
        if(tmp==-1) root=i;
        else tree[tmp].push_back(i);
    }
    dfs(root,0);
    maxPrice=p*pow(1+r,maxDepth);
    printf("%.2f %d",maxPrice,num);

    return 0;
}
~~~



# 1119 Pre- and Post-order Traversals (30 分)



Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.

Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.

### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.

### Output Specification:

For each test case, first printf in a line `Yes` if the tree is unique, or `No` if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.

### Sample Input 1:

```in
7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
```

### Sample Output 1:

```out
Yes
2 1 6 4 7 3 5
```

### Sample Input 2:

```in
4
1 2 3 4
2 4 3 1
```

### Sample Output 2:

```out
No
2 1 3 4
```



```C++
#include<iostream>
#include<vector>
using namespace std;
vector<int> pre,post,in;
bool isUnique=true;int inPos=0;
void inOrder(int root,int start,int eend){
    if(start>eend) return;
    int leftEnd=eend;
    while(pre[root+1]!=post[leftEnd]&&leftEnd!=-1) leftEnd--;
    int leftEndSize=leftEnd-start+1;
    if((start-eend+1)%2==0) isUnique=false;
    inOrder(root+1,start,leftEnd);
    in[inPos++]=pre[root];
    if(leftEnd!=-1) inOrder(root+1+leftEndSize,leftEnd+1,eend-1);
    else inOrder(root+1+leftEndSize,start+1,eend-1);//这里写错了逻辑不清楚，
}
int main(){
    int n;
    scanf("%d",&n);
    pre.resize(n);
    post.resize(n);
    in.resize(n);
    for(int i=0;i<n;i++) scanf("%d",&pre[i]);
    for(int i=0;i<n;i++) scanf("%d",&post[i]);
    inOrder(0,0,n-1);
    if(isUnique) printf("Yes\n");
    else printf("No\n");
    for(int i=0;i<n;i++)
        printf("%d%c",in[i],i==n-1?'\n':' ');
    return 0;
}
/*******************************************/
/*
逻辑不清楚，首先start和end谁是谁的没搞清楚
应该一个序列提供跟节点一个序列利用自己去锁定下一个根节点；同时更新一下自己的查找范围。
此外本次不同于普通的中序遍历，会出现特殊结果leftEnd=-1；的情况，没有充分考虑=-1的情况下
对后续的程序的影响（例如右子树的后序的锁定范围会出现变化）

逻辑想的慢：
正常：第一次做前后序转中序；难免会对下一次取值生疏
但是下次可以考量一下什么函数要做什么，这个变量的意义
如root start eend的意义搞清楚后就不会有模糊的地方了。

模板改进题：
如果出现了新的值要考虑对原有模板的代码的影响

学习方式：
搞清楚模板函数各个参量的意义，改变他会有造成什么影响

调试窗口的调用：
调试-》调试窗口-》监视
调试-》调试窗口-》调用栈
*/
/********************************************/


```

# 